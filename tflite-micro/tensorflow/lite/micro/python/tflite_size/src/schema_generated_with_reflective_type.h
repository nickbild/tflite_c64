// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_
#define FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_

#include "flatbuffers/flatbuffers.h"

namespace tflite {

struct CustomQuantization;

struct QuantizationParameters;

struct Int32Vector;

struct Uint16Vector;

struct Uint8Vector;

struct DimensionMetadata;

struct SparsityParameters;

struct Tensor;

struct Conv2DOptions;

struct Conv3DOptions;

struct Pool2DOptions;

struct DepthwiseConv2DOptions;

struct ConcatEmbeddingsOptions;

struct LSHProjectionOptions;

struct SVDFOptions;

struct RNNOptions;

struct SequenceRNNOptions;

struct BidirectionalSequenceRNNOptions;

struct FullyConnectedOptions;

struct SoftmaxOptions;

struct ConcatenationOptions;

struct AddOptions;

struct MulOptions;

struct L2NormOptions;

struct LocalResponseNormalizationOptions;

struct LSTMOptions;

struct UnidirectionalSequenceLSTMOptions;

struct BidirectionalSequenceLSTMOptions;

struct ResizeBilinearOptions;

struct ResizeNearestNeighborOptions;

struct CallOptions;

struct PadOptions;

struct PadV2Options;

struct ReshapeOptions;

struct SpaceToBatchNDOptions;

struct BatchToSpaceNDOptions;

struct SkipGramOptions;

struct SpaceToDepthOptions;

struct DepthToSpaceOptions;

struct SubOptions;

struct DivOptions;

struct TopKV2Options;

struct EmbeddingLookupSparseOptions;

struct GatherOptions;

struct TransposeOptions;

struct ExpOptions;

struct CosOptions;

struct ReducerOptions;

struct SqueezeOptions;

struct SplitOptions;

struct SplitVOptions;

struct StridedSliceOptions;

struct LogSoftmaxOptions;

struct CastOptions;

struct DequantizeOptions;

struct MaximumMinimumOptions;

struct TileOptions;

struct ArgMaxOptions;

struct ArgMinOptions;

struct GreaterOptions;

struct GreaterEqualOptions;

struct LessOptions;

struct LessEqualOptions;

struct NegOptions;

struct SelectOptions;

struct SliceOptions;

struct TransposeConvOptions;

struct ExpandDimsOptions;

struct SparseToDenseOptions;

struct EqualOptions;

struct NotEqualOptions;

struct ShapeOptions;

struct RankOptions;

struct PowOptions;

struct FakeQuantOptions;

struct PackOptions;

struct LogicalOrOptions;

struct OneHotOptions;

struct AbsOptions;

struct HardSwishOptions;

struct LogicalAndOptions;

struct LogicalNotOptions;

struct UnpackOptions;

struct FloorDivOptions;

struct SquareOptions;

struct ZerosLikeOptions;

struct FillOptions;

struct FloorModOptions;

struct RangeOptions;

struct LeakyReluOptions;

struct SquaredDifferenceOptions;

struct MirrorPadOptions;

struct UniqueOptions;

struct ReverseV2Options;

struct AddNOptions;

struct GatherNdOptions;

struct WhereOptions;

struct ReverseSequenceOptions;

struct MatrixDiagOptions;

struct QuantizeOptions;

struct MatrixSetDiagOptions;

struct IfOptions;

struct CallOnceOptions;

struct WhileOptions;

struct NonMaxSuppressionV4Options;

struct NonMaxSuppressionV5Options;

struct ScatterNdOptions;

struct SelectV2Options;

struct DensifyOptions;

struct SegmentSumOptions;

struct BatchMatMulOptions;

struct CumsumOptions;

struct BroadcastToOptions;

struct Rfft2dOptions;

struct HashtableOptions;

struct HashtableFindOptions;

struct HashtableImportOptions;

struct HashtableSizeOptions;

struct VarHandleOptions;

struct ReadVariableOptions;

struct AssignVariableOptions;

struct RandomOptions;

struct BucketizeOptions;

struct GeluOptions;

struct OperatorCode;

struct Operator;

struct SubGraph;

struct Buffer;

struct Metadata;

struct TensorMap;

struct SignatureDef;

struct Model;

inline const flatbuffers::TypeTable* CustomQuantizationTypeTable();

inline const flatbuffers::TypeTable* QuantizationParametersTypeTable();

inline const flatbuffers::TypeTable* Int32VectorTypeTable();

inline const flatbuffers::TypeTable* Uint16VectorTypeTable();

inline const flatbuffers::TypeTable* Uint8VectorTypeTable();

inline const flatbuffers::TypeTable* DimensionMetadataTypeTable();

inline const flatbuffers::TypeTable* SparsityParametersTypeTable();

inline const flatbuffers::TypeTable* TensorTypeTable();

inline const flatbuffers::TypeTable* Conv2DOptionsTypeTable();

inline const flatbuffers::TypeTable* Conv3DOptionsTypeTable();

inline const flatbuffers::TypeTable* Pool2DOptionsTypeTable();

inline const flatbuffers::TypeTable* DepthwiseConv2DOptionsTypeTable();

inline const flatbuffers::TypeTable* ConcatEmbeddingsOptionsTypeTable();

inline const flatbuffers::TypeTable* LSHProjectionOptionsTypeTable();

inline const flatbuffers::TypeTable* SVDFOptionsTypeTable();

inline const flatbuffers::TypeTable* RNNOptionsTypeTable();

inline const flatbuffers::TypeTable* SequenceRNNOptionsTypeTable();

inline const flatbuffers::TypeTable* BidirectionalSequenceRNNOptionsTypeTable();

inline const flatbuffers::TypeTable* FullyConnectedOptionsTypeTable();

inline const flatbuffers::TypeTable* SoftmaxOptionsTypeTable();

inline const flatbuffers::TypeTable* ConcatenationOptionsTypeTable();

inline const flatbuffers::TypeTable* AddOptionsTypeTable();

inline const flatbuffers::TypeTable* MulOptionsTypeTable();

inline const flatbuffers::TypeTable* L2NormOptionsTypeTable();

inline const flatbuffers::TypeTable*
LocalResponseNormalizationOptionsTypeTable();

inline const flatbuffers::TypeTable* LSTMOptionsTypeTable();

inline const flatbuffers::TypeTable*
UnidirectionalSequenceLSTMOptionsTypeTable();

inline const flatbuffers::TypeTable*
BidirectionalSequenceLSTMOptionsTypeTable();

inline const flatbuffers::TypeTable* ResizeBilinearOptionsTypeTable();

inline const flatbuffers::TypeTable* ResizeNearestNeighborOptionsTypeTable();

inline const flatbuffers::TypeTable* CallOptionsTypeTable();

inline const flatbuffers::TypeTable* PadOptionsTypeTable();

inline const flatbuffers::TypeTable* PadV2OptionsTypeTable();

inline const flatbuffers::TypeTable* ReshapeOptionsTypeTable();

inline const flatbuffers::TypeTable* SpaceToBatchNDOptionsTypeTable();

inline const flatbuffers::TypeTable* BatchToSpaceNDOptionsTypeTable();

inline const flatbuffers::TypeTable* SkipGramOptionsTypeTable();

inline const flatbuffers::TypeTable* SpaceToDepthOptionsTypeTable();

inline const flatbuffers::TypeTable* DepthToSpaceOptionsTypeTable();

inline const flatbuffers::TypeTable* SubOptionsTypeTable();

inline const flatbuffers::TypeTable* DivOptionsTypeTable();

inline const flatbuffers::TypeTable* TopKV2OptionsTypeTable();

inline const flatbuffers::TypeTable* EmbeddingLookupSparseOptionsTypeTable();

inline const flatbuffers::TypeTable* GatherOptionsTypeTable();

inline const flatbuffers::TypeTable* TransposeOptionsTypeTable();

inline const flatbuffers::TypeTable* ExpOptionsTypeTable();

inline const flatbuffers::TypeTable* CosOptionsTypeTable();

inline const flatbuffers::TypeTable* ReducerOptionsTypeTable();

inline const flatbuffers::TypeTable* SqueezeOptionsTypeTable();

inline const flatbuffers::TypeTable* SplitOptionsTypeTable();

inline const flatbuffers::TypeTable* SplitVOptionsTypeTable();

inline const flatbuffers::TypeTable* StridedSliceOptionsTypeTable();

inline const flatbuffers::TypeTable* LogSoftmaxOptionsTypeTable();

inline const flatbuffers::TypeTable* CastOptionsTypeTable();

inline const flatbuffers::TypeTable* DequantizeOptionsTypeTable();

inline const flatbuffers::TypeTable* MaximumMinimumOptionsTypeTable();

inline const flatbuffers::TypeTable* TileOptionsTypeTable();

inline const flatbuffers::TypeTable* ArgMaxOptionsTypeTable();

inline const flatbuffers::TypeTable* ArgMinOptionsTypeTable();

inline const flatbuffers::TypeTable* GreaterOptionsTypeTable();

inline const flatbuffers::TypeTable* GreaterEqualOptionsTypeTable();

inline const flatbuffers::TypeTable* LessOptionsTypeTable();

inline const flatbuffers::TypeTable* LessEqualOptionsTypeTable();

inline const flatbuffers::TypeTable* NegOptionsTypeTable();

inline const flatbuffers::TypeTable* SelectOptionsTypeTable();

inline const flatbuffers::TypeTable* SliceOptionsTypeTable();

inline const flatbuffers::TypeTable* TransposeConvOptionsTypeTable();

inline const flatbuffers::TypeTable* ExpandDimsOptionsTypeTable();

inline const flatbuffers::TypeTable* SparseToDenseOptionsTypeTable();

inline const flatbuffers::TypeTable* EqualOptionsTypeTable();

inline const flatbuffers::TypeTable* NotEqualOptionsTypeTable();

inline const flatbuffers::TypeTable* ShapeOptionsTypeTable();

inline const flatbuffers::TypeTable* RankOptionsTypeTable();

inline const flatbuffers::TypeTable* PowOptionsTypeTable();

inline const flatbuffers::TypeTable* FakeQuantOptionsTypeTable();

inline const flatbuffers::TypeTable* PackOptionsTypeTable();

inline const flatbuffers::TypeTable* LogicalOrOptionsTypeTable();

inline const flatbuffers::TypeTable* OneHotOptionsTypeTable();

inline const flatbuffers::TypeTable* AbsOptionsTypeTable();

inline const flatbuffers::TypeTable* HardSwishOptionsTypeTable();

inline const flatbuffers::TypeTable* LogicalAndOptionsTypeTable();

inline const flatbuffers::TypeTable* LogicalNotOptionsTypeTable();

inline const flatbuffers::TypeTable* UnpackOptionsTypeTable();

inline const flatbuffers::TypeTable* FloorDivOptionsTypeTable();

inline const flatbuffers::TypeTable* SquareOptionsTypeTable();

inline const flatbuffers::TypeTable* ZerosLikeOptionsTypeTable();

inline const flatbuffers::TypeTable* FillOptionsTypeTable();

inline const flatbuffers::TypeTable* FloorModOptionsTypeTable();

inline const flatbuffers::TypeTable* RangeOptionsTypeTable();

inline const flatbuffers::TypeTable* LeakyReluOptionsTypeTable();

inline const flatbuffers::TypeTable* SquaredDifferenceOptionsTypeTable();

inline const flatbuffers::TypeTable* MirrorPadOptionsTypeTable();

inline const flatbuffers::TypeTable* UniqueOptionsTypeTable();

inline const flatbuffers::TypeTable* ReverseV2OptionsTypeTable();

inline const flatbuffers::TypeTable* AddNOptionsTypeTable();

inline const flatbuffers::TypeTable* GatherNdOptionsTypeTable();

inline const flatbuffers::TypeTable* WhereOptionsTypeTable();

inline const flatbuffers::TypeTable* ReverseSequenceOptionsTypeTable();

inline const flatbuffers::TypeTable* MatrixDiagOptionsTypeTable();

inline const flatbuffers::TypeTable* QuantizeOptionsTypeTable();

inline const flatbuffers::TypeTable* MatrixSetDiagOptionsTypeTable();

inline const flatbuffers::TypeTable* IfOptionsTypeTable();

inline const flatbuffers::TypeTable* CallOnceOptionsTypeTable();

inline const flatbuffers::TypeTable* WhileOptionsTypeTable();

inline const flatbuffers::TypeTable* NonMaxSuppressionV4OptionsTypeTable();

inline const flatbuffers::TypeTable* NonMaxSuppressionV5OptionsTypeTable();

inline const flatbuffers::TypeTable* ScatterNdOptionsTypeTable();

inline const flatbuffers::TypeTable* SelectV2OptionsTypeTable();

inline const flatbuffers::TypeTable* DensifyOptionsTypeTable();

inline const flatbuffers::TypeTable* SegmentSumOptionsTypeTable();

inline const flatbuffers::TypeTable* BatchMatMulOptionsTypeTable();

inline const flatbuffers::TypeTable* CumsumOptionsTypeTable();

inline const flatbuffers::TypeTable* BroadcastToOptionsTypeTable();

inline const flatbuffers::TypeTable* Rfft2dOptionsTypeTable();

inline const flatbuffers::TypeTable* HashtableOptionsTypeTable();

inline const flatbuffers::TypeTable* HashtableFindOptionsTypeTable();

inline const flatbuffers::TypeTable* HashtableImportOptionsTypeTable();

inline const flatbuffers::TypeTable* HashtableSizeOptionsTypeTable();

inline const flatbuffers::TypeTable* VarHandleOptionsTypeTable();

inline const flatbuffers::TypeTable* ReadVariableOptionsTypeTable();

inline const flatbuffers::TypeTable* AssignVariableOptionsTypeTable();

inline const flatbuffers::TypeTable* RandomOptionsTypeTable();

inline const flatbuffers::TypeTable* BucketizeOptionsTypeTable();

inline const flatbuffers::TypeTable* GeluOptionsTypeTable();

inline const flatbuffers::TypeTable* OperatorCodeTypeTable();

inline const flatbuffers::TypeTable* OperatorTypeTable();

inline const flatbuffers::TypeTable* SubGraphTypeTable();

inline const flatbuffers::TypeTable* BufferTypeTable();

inline const flatbuffers::TypeTable* MetadataTypeTable();

inline const flatbuffers::TypeTable* TensorMapTypeTable();

inline const flatbuffers::TypeTable* SignatureDefTypeTable();

inline const flatbuffers::TypeTable* ModelTypeTable();

enum TensorType {
  TensorType_FLOAT32 = 0,
  TensorType_FLOAT16 = 1,
  TensorType_INT32 = 2,
  TensorType_UINT8 = 3,
  TensorType_INT64 = 4,
  TensorType_STRING = 5,
  TensorType_BOOL = 6,
  TensorType_INT16 = 7,
  TensorType_COMPLEX64 = 8,
  TensorType_INT8 = 9,
  TensorType_FLOAT64 = 10,
  TensorType_COMPLEX128 = 11,
  TensorType_UINT64 = 12,
  TensorType_RESOURCE = 13,
  TensorType_VARIANT = 14,
  TensorType_UINT32 = 15,
  TensorType_MIN = TensorType_FLOAT32,
  TensorType_MAX = TensorType_UINT32
};

inline const TensorType (&EnumValuesTensorType())[16] {
  static const TensorType values[] = {
      TensorType_FLOAT32, TensorType_FLOAT16,  TensorType_INT32,
      TensorType_UINT8,   TensorType_INT64,    TensorType_STRING,
      TensorType_BOOL,    TensorType_INT16,    TensorType_COMPLEX64,
      TensorType_INT8,    TensorType_FLOAT64,  TensorType_COMPLEX128,
      TensorType_UINT64,  TensorType_RESOURCE, TensorType_VARIANT,
      TensorType_UINT32};
  return values;
}

inline const char* const* EnumNamesTensorType() {
  static const char* const names[17] = {
      "FLOAT32", "FLOAT16",  "INT32",     "UINT8",  "INT64",   "STRING",
      "BOOL",    "INT16",    "COMPLEX64", "INT8",   "FLOAT64", "COMPLEX128",
      "UINT64",  "RESOURCE", "VARIANT",   "UINT32", nullptr};
  return names;
}

inline const char* EnumNameTensorType(TensorType e) {
  if (flatbuffers::IsOutRange(e, TensorType_FLOAT32, TensorType_UINT32))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensorType()[index];
}

enum QuantizationDetails {
  QuantizationDetails_NONE = 0,
  QuantizationDetails_CustomQuantization = 1,
  QuantizationDetails_MIN = QuantizationDetails_NONE,
  QuantizationDetails_MAX = QuantizationDetails_CustomQuantization
};

inline const QuantizationDetails (&EnumValuesQuantizationDetails())[2] {
  static const QuantizationDetails values[] = {
      QuantizationDetails_NONE, QuantizationDetails_CustomQuantization};
  return values;
}

inline const char* const* EnumNamesQuantizationDetails() {
  static const char* const names[3] = {"NONE", "CustomQuantization", nullptr};
  return names;
}

inline const char* EnumNameQuantizationDetails(QuantizationDetails e) {
  if (flatbuffers::IsOutRange(e, QuantizationDetails_NONE,
                              QuantizationDetails_CustomQuantization))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantizationDetails()[index];
}

template <typename T>
struct QuantizationDetailsTraits {
  static const QuantizationDetails enum_value = QuantizationDetails_NONE;
};

template <>
struct QuantizationDetailsTraits<tflite::CustomQuantization> {
  static const QuantizationDetails enum_value =
      QuantizationDetails_CustomQuantization;
};

bool VerifyQuantizationDetails(flatbuffers::Verifier& verifier, const void* obj,
                               QuantizationDetails type);
bool VerifyQuantizationDetailsVector(
    flatbuffers::Verifier& verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
    const flatbuffers::Vector<uint8_t>* types);

enum DimensionType {
  DimensionType_DENSE = 0,
  DimensionType_SPARSE_CSR = 1,
  DimensionType_MIN = DimensionType_DENSE,
  DimensionType_MAX = DimensionType_SPARSE_CSR
};

inline const DimensionType (&EnumValuesDimensionType())[2] {
  static const DimensionType values[] = {DimensionType_DENSE,
                                         DimensionType_SPARSE_CSR};
  return values;
}

inline const char* const* EnumNamesDimensionType() {
  static const char* const names[3] = {"DENSE", "SPARSE_CSR", nullptr};
  return names;
}

inline const char* EnumNameDimensionType(DimensionType e) {
  if (flatbuffers::IsOutRange(e, DimensionType_DENSE, DimensionType_SPARSE_CSR))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDimensionType()[index];
}

enum SparseIndexVector {
  SparseIndexVector_NONE = 0,
  SparseIndexVector_Int32Vector = 1,
  SparseIndexVector_Uint16Vector = 2,
  SparseIndexVector_Uint8Vector = 3,
  SparseIndexVector_MIN = SparseIndexVector_NONE,
  SparseIndexVector_MAX = SparseIndexVector_Uint8Vector
};

inline const SparseIndexVector (&EnumValuesSparseIndexVector())[4] {
  static const SparseIndexVector values[] = {
      SparseIndexVector_NONE, SparseIndexVector_Int32Vector,
      SparseIndexVector_Uint16Vector, SparseIndexVector_Uint8Vector};
  return values;
}

inline const char* const* EnumNamesSparseIndexVector() {
  static const char* const names[5] = {"NONE", "Int32Vector", "Uint16Vector",
                                       "Uint8Vector", nullptr};
  return names;
}

inline const char* EnumNameSparseIndexVector(SparseIndexVector e) {
  if (flatbuffers::IsOutRange(e, SparseIndexVector_NONE,
                              SparseIndexVector_Uint8Vector))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSparseIndexVector()[index];
}

template <typename T>
struct SparseIndexVectorTraits {
  static const SparseIndexVector enum_value = SparseIndexVector_NONE;
};

template <>
struct SparseIndexVectorTraits<tflite::Int32Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Int32Vector;
};

template <>
struct SparseIndexVectorTraits<tflite::Uint16Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Uint16Vector;
};

template <>
struct SparseIndexVectorTraits<tflite::Uint8Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Uint8Vector;
};

bool VerifySparseIndexVector(flatbuffers::Verifier& verifier, const void* obj,
                             SparseIndexVector type);
bool VerifySparseIndexVectorVector(
    flatbuffers::Verifier& verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
    const flatbuffers::Vector<uint8_t>* types);

enum BuiltinOperator {
  BuiltinOperator_ADD = 0,
  BuiltinOperator_AVERAGE_POOL_2D = 1,
  BuiltinOperator_CONCATENATION = 2,
  BuiltinOperator_CONV_2D = 3,
  BuiltinOperator_DEPTHWISE_CONV_2D = 4,
  BuiltinOperator_DEPTH_TO_SPACE = 5,
  BuiltinOperator_DEQUANTIZE = 6,
  BuiltinOperator_EMBEDDING_LOOKUP = 7,
  BuiltinOperator_FLOOR = 8,
  BuiltinOperator_FULLY_CONNECTED = 9,
  BuiltinOperator_HASHTABLE_LOOKUP = 10,
  BuiltinOperator_L2_NORMALIZATION = 11,
  BuiltinOperator_L2_POOL_2D = 12,
  BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION = 13,
  BuiltinOperator_LOGISTIC = 14,
  BuiltinOperator_LSH_PROJECTION = 15,
  BuiltinOperator_LSTM = 16,
  BuiltinOperator_MAX_POOL_2D = 17,
  BuiltinOperator_MUL = 18,
  BuiltinOperator_RELU = 19,
  BuiltinOperator_RELU_N1_TO_1 = 20,
  BuiltinOperator_RELU6 = 21,
  BuiltinOperator_RESHAPE = 22,
  BuiltinOperator_RESIZE_BILINEAR = 23,
  BuiltinOperator_RNN = 24,
  BuiltinOperator_SOFTMAX = 25,
  BuiltinOperator_SPACE_TO_DEPTH = 26,
  BuiltinOperator_SVDF = 27,
  BuiltinOperator_TANH = 28,
  BuiltinOperator_CONCAT_EMBEDDINGS = 29,
  BuiltinOperator_SKIP_GRAM = 30,
  BuiltinOperator_CALL = 31,
  BuiltinOperator_CUSTOM = 32,
  BuiltinOperator_EMBEDDING_LOOKUP_SPARSE = 33,
  BuiltinOperator_PAD = 34,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN = 35,
  BuiltinOperator_GATHER = 36,
  BuiltinOperator_BATCH_TO_SPACE_ND = 37,
  BuiltinOperator_SPACE_TO_BATCH_ND = 38,
  BuiltinOperator_TRANSPOSE = 39,
  BuiltinOperator_MEAN = 40,
  BuiltinOperator_SUB = 41,
  BuiltinOperator_DIV = 42,
  BuiltinOperator_SQUEEZE = 43,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
  BuiltinOperator_STRIDED_SLICE = 45,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN = 46,
  BuiltinOperator_EXP = 47,
  BuiltinOperator_TOPK_V2 = 48,
  BuiltinOperator_SPLIT = 49,
  BuiltinOperator_LOG_SOFTMAX = 50,
  BuiltinOperator_DELEGATE = 51,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM = 52,
  BuiltinOperator_CAST = 53,
  BuiltinOperator_PRELU = 54,
  BuiltinOperator_MAXIMUM = 55,
  BuiltinOperator_ARG_MAX = 56,
  BuiltinOperator_MINIMUM = 57,
  BuiltinOperator_LESS = 58,
  BuiltinOperator_NEG = 59,
  BuiltinOperator_PADV2 = 60,
  BuiltinOperator_GREATER = 61,
  BuiltinOperator_GREATER_EQUAL = 62,
  BuiltinOperator_LESS_EQUAL = 63,
  BuiltinOperator_SELECT = 64,
  BuiltinOperator_SLICE = 65,
  BuiltinOperator_SIN = 66,
  BuiltinOperator_TRANSPOSE_CONV = 67,
  BuiltinOperator_SPARSE_TO_DENSE = 68,
  BuiltinOperator_TILE = 69,
  BuiltinOperator_EXPAND_DIMS = 70,
  BuiltinOperator_EQUAL = 71,
  BuiltinOperator_NOT_EQUAL = 72,
  BuiltinOperator_LOG = 73,
  BuiltinOperator_SUM = 74,
  BuiltinOperator_SQRT = 75,
  BuiltinOperator_RSQRT = 76,
  BuiltinOperator_SHAPE = 77,
  BuiltinOperator_POW = 78,
  BuiltinOperator_ARG_MIN = 79,
  BuiltinOperator_FAKE_QUANT = 80,
  BuiltinOperator_REDUCE_PROD = 81,
  BuiltinOperator_REDUCE_MAX = 82,
  BuiltinOperator_PACK = 83,
  BuiltinOperator_LOGICAL_OR = 84,
  BuiltinOperator_ONE_HOT = 85,
  BuiltinOperator_LOGICAL_AND = 86,
  BuiltinOperator_LOGICAL_NOT = 87,
  BuiltinOperator_UNPACK = 88,
  BuiltinOperator_REDUCE_MIN = 89,
  BuiltinOperator_FLOOR_DIV = 90,
  BuiltinOperator_REDUCE_ANY = 91,
  BuiltinOperator_SQUARE = 92,
  BuiltinOperator_ZEROS_LIKE = 93,
  BuiltinOperator_FILL = 94,
  BuiltinOperator_FLOOR_MOD = 95,
  BuiltinOperator_RANGE = 96,
  BuiltinOperator_RESIZE_NEAREST_NEIGHBOR = 97,
  BuiltinOperator_LEAKY_RELU = 98,
  BuiltinOperator_SQUARED_DIFFERENCE = 99,
  BuiltinOperator_MIRROR_PAD = 100,
  BuiltinOperator_ABS = 101,
  BuiltinOperator_SPLIT_V = 102,
  BuiltinOperator_UNIQUE = 103,
  BuiltinOperator_CEIL = 104,
  BuiltinOperator_REVERSE_V2 = 105,
  BuiltinOperator_ADD_N = 106,
  BuiltinOperator_GATHER_ND = 107,
  BuiltinOperator_COS = 108,
  BuiltinOperator_WHERE = 109,
  BuiltinOperator_RANK = 110,
  BuiltinOperator_ELU = 111,
  BuiltinOperator_REVERSE_SEQUENCE = 112,
  BuiltinOperator_MATRIX_DIAG = 113,
  BuiltinOperator_QUANTIZE = 114,
  BuiltinOperator_MATRIX_SET_DIAG = 115,
  BuiltinOperator_ROUND = 116,
  BuiltinOperator_HARD_SWISH = 117,
  BuiltinOperator_IF = 118,
  BuiltinOperator_WHILE = 119,
  BuiltinOperator_NON_MAX_SUPPRESSION_V4 = 120,
  BuiltinOperator_NON_MAX_SUPPRESSION_V5 = 121,
  BuiltinOperator_SCATTER_ND = 122,
  BuiltinOperator_SELECT_V2 = 123,
  BuiltinOperator_DENSIFY = 124,
  BuiltinOperator_SEGMENT_SUM = 125,
  BuiltinOperator_BATCH_MATMUL = 126,
  BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES = 127,
  BuiltinOperator_CUMSUM = 128,
  BuiltinOperator_CALL_ONCE = 129,
  BuiltinOperator_BROADCAST_TO = 130,
  BuiltinOperator_RFFT2D = 131,
  BuiltinOperator_CONV_3D = 132,
  BuiltinOperator_IMAG = 133,
  BuiltinOperator_REAL = 134,
  BuiltinOperator_COMPLEX_ABS = 135,
  BuiltinOperator_HASHTABLE = 136,
  BuiltinOperator_HASHTABLE_FIND = 137,
  BuiltinOperator_HASHTABLE_IMPORT = 138,
  BuiltinOperator_HASHTABLE_SIZE = 139,
  BuiltinOperator_REDUCE_ALL = 140,
  BuiltinOperator_CONV_3D_TRANSPOSE = 141,
  BuiltinOperator_VAR_HANDLE = 142,
  BuiltinOperator_READ_VARIABLE = 143,
  BuiltinOperator_ASSIGN_VARIABLE = 144,
  BuiltinOperator_BROADCAST_ARGS = 145,
  BuiltinOperator_RANDOM_STANDARD_NORMAL = 146,
  BuiltinOperator_BUCKETIZE = 147,
  BuiltinOperator_RANDOM_UNIFORM = 148,
  BuiltinOperator_MULTINOMIAL = 149,
  BuiltinOperator_GELU = 150,
  BuiltinOperator_MIN = BuiltinOperator_ADD,
  BuiltinOperator_MAX = BuiltinOperator_GELU
};

inline const BuiltinOperator (&EnumValuesBuiltinOperator())[151] {
  static const BuiltinOperator values[] = {
      BuiltinOperator_ADD,
      BuiltinOperator_AVERAGE_POOL_2D,
      BuiltinOperator_CONCATENATION,
      BuiltinOperator_CONV_2D,
      BuiltinOperator_DEPTHWISE_CONV_2D,
      BuiltinOperator_DEPTH_TO_SPACE,
      BuiltinOperator_DEQUANTIZE,
      BuiltinOperator_EMBEDDING_LOOKUP,
      BuiltinOperator_FLOOR,
      BuiltinOperator_FULLY_CONNECTED,
      BuiltinOperator_HASHTABLE_LOOKUP,
      BuiltinOperator_L2_NORMALIZATION,
      BuiltinOperator_L2_POOL_2D,
      BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION,
      BuiltinOperator_LOGISTIC,
      BuiltinOperator_LSH_PROJECTION,
      BuiltinOperator_LSTM,
      BuiltinOperator_MAX_POOL_2D,
      BuiltinOperator_MUL,
      BuiltinOperator_RELU,
      BuiltinOperator_RELU_N1_TO_1,
      BuiltinOperator_RELU6,
      BuiltinOperator_RESHAPE,
      BuiltinOperator_RESIZE_BILINEAR,
      BuiltinOperator_RNN,
      BuiltinOperator_SOFTMAX,
      BuiltinOperator_SPACE_TO_DEPTH,
      BuiltinOperator_SVDF,
      BuiltinOperator_TANH,
      BuiltinOperator_CONCAT_EMBEDDINGS,
      BuiltinOperator_SKIP_GRAM,
      BuiltinOperator_CALL,
      BuiltinOperator_CUSTOM,
      BuiltinOperator_EMBEDDING_LOOKUP_SPARSE,
      BuiltinOperator_PAD,
      BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN,
      BuiltinOperator_GATHER,
      BuiltinOperator_BATCH_TO_SPACE_ND,
      BuiltinOperator_SPACE_TO_BATCH_ND,
      BuiltinOperator_TRANSPOSE,
      BuiltinOperator_MEAN,
      BuiltinOperator_SUB,
      BuiltinOperator_DIV,
      BuiltinOperator_SQUEEZE,
      BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM,
      BuiltinOperator_STRIDED_SLICE,
      BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN,
      BuiltinOperator_EXP,
      BuiltinOperator_TOPK_V2,
      BuiltinOperator_SPLIT,
      BuiltinOperator_LOG_SOFTMAX,
      BuiltinOperator_DELEGATE,
      BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM,
      BuiltinOperator_CAST,
      BuiltinOperator_PRELU,
      BuiltinOperator_MAXIMUM,
      BuiltinOperator_ARG_MAX,
      BuiltinOperator_MINIMUM,
      BuiltinOperator_LESS,
      BuiltinOperator_NEG,
      BuiltinOperator_PADV2,
      BuiltinOperator_GREATER,
      BuiltinOperator_GREATER_EQUAL,
      BuiltinOperator_LESS_EQUAL,
      BuiltinOperator_SELECT,
      BuiltinOperator_SLICE,
      BuiltinOperator_SIN,
      BuiltinOperator_TRANSPOSE_CONV,
      BuiltinOperator_SPARSE_TO_DENSE,
      BuiltinOperator_TILE,
      BuiltinOperator_EXPAND_DIMS,
      BuiltinOperator_EQUAL,
      BuiltinOperator_NOT_EQUAL,
      BuiltinOperator_LOG,
      BuiltinOperator_SUM,
      BuiltinOperator_SQRT,
      BuiltinOperator_RSQRT,
      BuiltinOperator_SHAPE,
      BuiltinOperator_POW,
      BuiltinOperator_ARG_MIN,
      BuiltinOperator_FAKE_QUANT,
      BuiltinOperator_REDUCE_PROD,
      BuiltinOperator_REDUCE_MAX,
      BuiltinOperator_PACK,
      BuiltinOperator_LOGICAL_OR,
      BuiltinOperator_ONE_HOT,
      BuiltinOperator_LOGICAL_AND,
      BuiltinOperator_LOGICAL_NOT,
      BuiltinOperator_UNPACK,
      BuiltinOperator_REDUCE_MIN,
      BuiltinOperator_FLOOR_DIV,
      BuiltinOperator_REDUCE_ANY,
      BuiltinOperator_SQUARE,
      BuiltinOperator_ZEROS_LIKE,
      BuiltinOperator_FILL,
      BuiltinOperator_FLOOR_MOD,
      BuiltinOperator_RANGE,
      BuiltinOperator_RESIZE_NEAREST_NEIGHBOR,
      BuiltinOperator_LEAKY_RELU,
      BuiltinOperator_SQUARED_DIFFERENCE,
      BuiltinOperator_MIRROR_PAD,
      BuiltinOperator_ABS,
      BuiltinOperator_SPLIT_V,
      BuiltinOperator_UNIQUE,
      BuiltinOperator_CEIL,
      BuiltinOperator_REVERSE_V2,
      BuiltinOperator_ADD_N,
      BuiltinOperator_GATHER_ND,
      BuiltinOperator_COS,
      BuiltinOperator_WHERE,
      BuiltinOperator_RANK,
      BuiltinOperator_ELU,
      BuiltinOperator_REVERSE_SEQUENCE,
      BuiltinOperator_MATRIX_DIAG,
      BuiltinOperator_QUANTIZE,
      BuiltinOperator_MATRIX_SET_DIAG,
      BuiltinOperator_ROUND,
      BuiltinOperator_HARD_SWISH,
      BuiltinOperator_IF,
      BuiltinOperator_WHILE,
      BuiltinOperator_NON_MAX_SUPPRESSION_V4,
      BuiltinOperator_NON_MAX_SUPPRESSION_V5,
      BuiltinOperator_SCATTER_ND,
      BuiltinOperator_SELECT_V2,
      BuiltinOperator_DENSIFY,
      BuiltinOperator_SEGMENT_SUM,
      BuiltinOperator_BATCH_MATMUL,
      BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES,
      BuiltinOperator_CUMSUM,
      BuiltinOperator_CALL_ONCE,
      BuiltinOperator_BROADCAST_TO,
      BuiltinOperator_RFFT2D,
      BuiltinOperator_CONV_3D,
      BuiltinOperator_IMAG,
      BuiltinOperator_REAL,
      BuiltinOperator_COMPLEX_ABS,
      BuiltinOperator_HASHTABLE,
      BuiltinOperator_HASHTABLE_FIND,
      BuiltinOperator_HASHTABLE_IMPORT,
      BuiltinOperator_HASHTABLE_SIZE,
      BuiltinOperator_REDUCE_ALL,
      BuiltinOperator_CONV_3D_TRANSPOSE,
      BuiltinOperator_VAR_HANDLE,
      BuiltinOperator_READ_VARIABLE,
      BuiltinOperator_ASSIGN_VARIABLE,
      BuiltinOperator_BROADCAST_ARGS,
      BuiltinOperator_RANDOM_STANDARD_NORMAL,
      BuiltinOperator_BUCKETIZE,
      BuiltinOperator_RANDOM_UNIFORM,
      BuiltinOperator_MULTINOMIAL,
      BuiltinOperator_GELU};
  return values;
}

inline const char* const* EnumNamesBuiltinOperator() {
  static const char* const names[152] = {"ADD",
                                         "AVERAGE_POOL_2D",
                                         "CONCATENATION",
                                         "CONV_2D",
                                         "DEPTHWISE_CONV_2D",
                                         "DEPTH_TO_SPACE",
                                         "DEQUANTIZE",
                                         "EMBEDDING_LOOKUP",
                                         "FLOOR",
                                         "FULLY_CONNECTED",
                                         "HASHTABLE_LOOKUP",
                                         "L2_NORMALIZATION",
                                         "L2_POOL_2D",
                                         "LOCAL_RESPONSE_NORMALIZATION",
                                         "LOGISTIC",
                                         "LSH_PROJECTION",
                                         "LSTM",
                                         "MAX_POOL_2D",
                                         "MUL",
                                         "RELU",
                                         "RELU_N1_TO_1",
                                         "RELU6",
                                         "RESHAPE",
                                         "RESIZE_BILINEAR",
                                         "RNN",
                                         "SOFTMAX",
                                         "SPACE_TO_DEPTH",
                                         "SVDF",
                                         "TANH",
                                         "CONCAT_EMBEDDINGS",
                                         "SKIP_GRAM",
                                         "CALL",
                                         "CUSTOM",
                                         "EMBEDDING_LOOKUP_SPARSE",
                                         "PAD",
                                         "UNIDIRECTIONAL_SEQUENCE_RNN",
                                         "GATHER",
                                         "BATCH_TO_SPACE_ND",
                                         "SPACE_TO_BATCH_ND",
                                         "TRANSPOSE",
                                         "MEAN",
                                         "SUB",
                                         "DIV",
                                         "SQUEEZE",
                                         "UNIDIRECTIONAL_SEQUENCE_LSTM",
                                         "STRIDED_SLICE",
                                         "BIDIRECTIONAL_SEQUENCE_RNN",
                                         "EXP",
                                         "TOPK_V2",
                                         "SPLIT",
                                         "LOG_SOFTMAX",
                                         "DELEGATE",
                                         "BIDIRECTIONAL_SEQUENCE_LSTM",
                                         "CAST",
                                         "PRELU",
                                         "MAXIMUM",
                                         "ARG_MAX",
                                         "MINIMUM",
                                         "LESS",
                                         "NEG",
                                         "PADV2",
                                         "GREATER",
                                         "GREATER_EQUAL",
                                         "LESS_EQUAL",
                                         "SELECT",
                                         "SLICE",
                                         "SIN",
                                         "TRANSPOSE_CONV",
                                         "SPARSE_TO_DENSE",
                                         "TILE",
                                         "EXPAND_DIMS",
                                         "EQUAL",
                                         "NOT_EQUAL",
                                         "LOG",
                                         "SUM",
                                         "SQRT",
                                         "RSQRT",
                                         "SHAPE",
                                         "POW",
                                         "ARG_MIN",
                                         "FAKE_QUANT",
                                         "REDUCE_PROD",
                                         "REDUCE_MAX",
                                         "PACK",
                                         "LOGICAL_OR",
                                         "ONE_HOT",
                                         "LOGICAL_AND",
                                         "LOGICAL_NOT",
                                         "UNPACK",
                                         "REDUCE_MIN",
                                         "FLOOR_DIV",
                                         "REDUCE_ANY",
                                         "SQUARE",
                                         "ZEROS_LIKE",
                                         "FILL",
                                         "FLOOR_MOD",
                                         "RANGE",
                                         "RESIZE_NEAREST_NEIGHBOR",
                                         "LEAKY_RELU",
                                         "SQUARED_DIFFERENCE",
                                         "MIRROR_PAD",
                                         "ABS",
                                         "SPLIT_V",
                                         "UNIQUE",
                                         "CEIL",
                                         "REVERSE_V2",
                                         "ADD_N",
                                         "GATHER_ND",
                                         "COS",
                                         "WHERE",
                                         "RANK",
                                         "ELU",
                                         "REVERSE_SEQUENCE",
                                         "MATRIX_DIAG",
                                         "QUANTIZE",
                                         "MATRIX_SET_DIAG",
                                         "ROUND",
                                         "HARD_SWISH",
                                         "IF",
                                         "WHILE",
                                         "NON_MAX_SUPPRESSION_V4",
                                         "NON_MAX_SUPPRESSION_V5",
                                         "SCATTER_ND",
                                         "SELECT_V2",
                                         "DENSIFY",
                                         "SEGMENT_SUM",
                                         "BATCH_MATMUL",
                                         "PLACEHOLDER_FOR_GREATER_OP_CODES",
                                         "CUMSUM",
                                         "CALL_ONCE",
                                         "BROADCAST_TO",
                                         "RFFT2D",
                                         "CONV_3D",
                                         "IMAG",
                                         "REAL",
                                         "COMPLEX_ABS",
                                         "HASHTABLE",
                                         "HASHTABLE_FIND",
                                         "HASHTABLE_IMPORT",
                                         "HASHTABLE_SIZE",
                                         "REDUCE_ALL",
                                         "CONV_3D_TRANSPOSE",
                                         "VAR_HANDLE",
                                         "READ_VARIABLE",
                                         "ASSIGN_VARIABLE",
                                         "BROADCAST_ARGS",
                                         "RANDOM_STANDARD_NORMAL",
                                         "BUCKETIZE",
                                         "RANDOM_UNIFORM",
                                         "MULTINOMIAL",
                                         "GELU",
                                         nullptr};
  return names;
}

inline const char* EnumNameBuiltinOperator(BuiltinOperator e) {
  if (flatbuffers::IsOutRange(e, BuiltinOperator_ADD, BuiltinOperator_GELU))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBuiltinOperator()[index];
}

enum BuiltinOptions {
  BuiltinOptions_NONE = 0,
  BuiltinOptions_Conv2DOptions = 1,
  BuiltinOptions_DepthwiseConv2DOptions = 2,
  BuiltinOptions_ConcatEmbeddingsOptions = 3,
  BuiltinOptions_LSHProjectionOptions = 4,
  BuiltinOptions_Pool2DOptions = 5,
  BuiltinOptions_SVDFOptions = 6,
  BuiltinOptions_RNNOptions = 7,
  BuiltinOptions_FullyConnectedOptions = 8,
  BuiltinOptions_SoftmaxOptions = 9,
  BuiltinOptions_ConcatenationOptions = 10,
  BuiltinOptions_AddOptions = 11,
  BuiltinOptions_L2NormOptions = 12,
  BuiltinOptions_LocalResponseNormalizationOptions = 13,
  BuiltinOptions_LSTMOptions = 14,
  BuiltinOptions_ResizeBilinearOptions = 15,
  BuiltinOptions_CallOptions = 16,
  BuiltinOptions_ReshapeOptions = 17,
  BuiltinOptions_SkipGramOptions = 18,
  BuiltinOptions_SpaceToDepthOptions = 19,
  BuiltinOptions_EmbeddingLookupSparseOptions = 20,
  BuiltinOptions_MulOptions = 21,
  BuiltinOptions_PadOptions = 22,
  BuiltinOptions_GatherOptions = 23,
  BuiltinOptions_BatchToSpaceNDOptions = 24,
  BuiltinOptions_SpaceToBatchNDOptions = 25,
  BuiltinOptions_TransposeOptions = 26,
  BuiltinOptions_ReducerOptions = 27,
  BuiltinOptions_SubOptions = 28,
  BuiltinOptions_DivOptions = 29,
  BuiltinOptions_SqueezeOptions = 30,
  BuiltinOptions_SequenceRNNOptions = 31,
  BuiltinOptions_StridedSliceOptions = 32,
  BuiltinOptions_ExpOptions = 33,
  BuiltinOptions_TopKV2Options = 34,
  BuiltinOptions_SplitOptions = 35,
  BuiltinOptions_LogSoftmaxOptions = 36,
  BuiltinOptions_CastOptions = 37,
  BuiltinOptions_DequantizeOptions = 38,
  BuiltinOptions_MaximumMinimumOptions = 39,
  BuiltinOptions_ArgMaxOptions = 40,
  BuiltinOptions_LessOptions = 41,
  BuiltinOptions_NegOptions = 42,
  BuiltinOptions_PadV2Options = 43,
  BuiltinOptions_GreaterOptions = 44,
  BuiltinOptions_GreaterEqualOptions = 45,
  BuiltinOptions_LessEqualOptions = 46,
  BuiltinOptions_SelectOptions = 47,
  BuiltinOptions_SliceOptions = 48,
  BuiltinOptions_TransposeConvOptions = 49,
  BuiltinOptions_SparseToDenseOptions = 50,
  BuiltinOptions_TileOptions = 51,
  BuiltinOptions_ExpandDimsOptions = 52,
  BuiltinOptions_EqualOptions = 53,
  BuiltinOptions_NotEqualOptions = 54,
  BuiltinOptions_ShapeOptions = 55,
  BuiltinOptions_PowOptions = 56,
  BuiltinOptions_ArgMinOptions = 57,
  BuiltinOptions_FakeQuantOptions = 58,
  BuiltinOptions_PackOptions = 59,
  BuiltinOptions_LogicalOrOptions = 60,
  BuiltinOptions_OneHotOptions = 61,
  BuiltinOptions_LogicalAndOptions = 62,
  BuiltinOptions_LogicalNotOptions = 63,
  BuiltinOptions_UnpackOptions = 64,
  BuiltinOptions_FloorDivOptions = 65,
  BuiltinOptions_SquareOptions = 66,
  BuiltinOptions_ZerosLikeOptions = 67,
  BuiltinOptions_FillOptions = 68,
  BuiltinOptions_BidirectionalSequenceLSTMOptions = 69,
  BuiltinOptions_BidirectionalSequenceRNNOptions = 70,
  BuiltinOptions_UnidirectionalSequenceLSTMOptions = 71,
  BuiltinOptions_FloorModOptions = 72,
  BuiltinOptions_RangeOptions = 73,
  BuiltinOptions_ResizeNearestNeighborOptions = 74,
  BuiltinOptions_LeakyReluOptions = 75,
  BuiltinOptions_SquaredDifferenceOptions = 76,
  BuiltinOptions_MirrorPadOptions = 77,
  BuiltinOptions_AbsOptions = 78,
  BuiltinOptions_SplitVOptions = 79,
  BuiltinOptions_UniqueOptions = 80,
  BuiltinOptions_ReverseV2Options = 81,
  BuiltinOptions_AddNOptions = 82,
  BuiltinOptions_GatherNdOptions = 83,
  BuiltinOptions_CosOptions = 84,
  BuiltinOptions_WhereOptions = 85,
  BuiltinOptions_RankOptions = 86,
  BuiltinOptions_ReverseSequenceOptions = 87,
  BuiltinOptions_MatrixDiagOptions = 88,
  BuiltinOptions_QuantizeOptions = 89,
  BuiltinOptions_MatrixSetDiagOptions = 90,
  BuiltinOptions_HardSwishOptions = 91,
  BuiltinOptions_IfOptions = 92,
  BuiltinOptions_WhileOptions = 93,
  BuiltinOptions_DepthToSpaceOptions = 94,
  BuiltinOptions_NonMaxSuppressionV4Options = 95,
  BuiltinOptions_NonMaxSuppressionV5Options = 96,
  BuiltinOptions_ScatterNdOptions = 97,
  BuiltinOptions_SelectV2Options = 98,
  BuiltinOptions_DensifyOptions = 99,
  BuiltinOptions_SegmentSumOptions = 100,
  BuiltinOptions_BatchMatMulOptions = 101,
  BuiltinOptions_CumsumOptions = 102,
  BuiltinOptions_CallOnceOptions = 103,
  BuiltinOptions_BroadcastToOptions = 104,
  BuiltinOptions_Rfft2dOptions = 105,
  BuiltinOptions_Conv3DOptions = 106,
  BuiltinOptions_HashtableOptions = 107,
  BuiltinOptions_HashtableFindOptions = 108,
  BuiltinOptions_HashtableImportOptions = 109,
  BuiltinOptions_HashtableSizeOptions = 110,
  BuiltinOptions_VarHandleOptions = 111,
  BuiltinOptions_ReadVariableOptions = 112,
  BuiltinOptions_AssignVariableOptions = 113,
  BuiltinOptions_RandomOptions = 114,
  BuiltinOptions_BucketizeOptions = 115,
  BuiltinOptions_GeluOptions = 116,
  BuiltinOptions_MIN = BuiltinOptions_NONE,
  BuiltinOptions_MAX = BuiltinOptions_GeluOptions
};

inline const BuiltinOptions (&EnumValuesBuiltinOptions())[117] {
  static const BuiltinOptions values[] = {
      BuiltinOptions_NONE,
      BuiltinOptions_Conv2DOptions,
      BuiltinOptions_DepthwiseConv2DOptions,
      BuiltinOptions_ConcatEmbeddingsOptions,
      BuiltinOptions_LSHProjectionOptions,
      BuiltinOptions_Pool2DOptions,
      BuiltinOptions_SVDFOptions,
      BuiltinOptions_RNNOptions,
      BuiltinOptions_FullyConnectedOptions,
      BuiltinOptions_SoftmaxOptions,
      BuiltinOptions_ConcatenationOptions,
      BuiltinOptions_AddOptions,
      BuiltinOptions_L2NormOptions,
      BuiltinOptions_LocalResponseNormalizationOptions,
      BuiltinOptions_LSTMOptions,
      BuiltinOptions_ResizeBilinearOptions,
      BuiltinOptions_CallOptions,
      BuiltinOptions_ReshapeOptions,
      BuiltinOptions_SkipGramOptions,
      BuiltinOptions_SpaceToDepthOptions,
      BuiltinOptions_EmbeddingLookupSparseOptions,
      BuiltinOptions_MulOptions,
      BuiltinOptions_PadOptions,
      BuiltinOptions_GatherOptions,
      BuiltinOptions_BatchToSpaceNDOptions,
      BuiltinOptions_SpaceToBatchNDOptions,
      BuiltinOptions_TransposeOptions,
      BuiltinOptions_ReducerOptions,
      BuiltinOptions_SubOptions,
      BuiltinOptions_DivOptions,
      BuiltinOptions_SqueezeOptions,
      BuiltinOptions_SequenceRNNOptions,
      BuiltinOptions_StridedSliceOptions,
      BuiltinOptions_ExpOptions,
      BuiltinOptions_TopKV2Options,
      BuiltinOptions_SplitOptions,
      BuiltinOptions_LogSoftmaxOptions,
      BuiltinOptions_CastOptions,
      BuiltinOptions_DequantizeOptions,
      BuiltinOptions_MaximumMinimumOptions,
      BuiltinOptions_ArgMaxOptions,
      BuiltinOptions_LessOptions,
      BuiltinOptions_NegOptions,
      BuiltinOptions_PadV2Options,
      BuiltinOptions_GreaterOptions,
      BuiltinOptions_GreaterEqualOptions,
      BuiltinOptions_LessEqualOptions,
      BuiltinOptions_SelectOptions,
      BuiltinOptions_SliceOptions,
      BuiltinOptions_TransposeConvOptions,
      BuiltinOptions_SparseToDenseOptions,
      BuiltinOptions_TileOptions,
      BuiltinOptions_ExpandDimsOptions,
      BuiltinOptions_EqualOptions,
      BuiltinOptions_NotEqualOptions,
      BuiltinOptions_ShapeOptions,
      BuiltinOptions_PowOptions,
      BuiltinOptions_ArgMinOptions,
      BuiltinOptions_FakeQuantOptions,
      BuiltinOptions_PackOptions,
      BuiltinOptions_LogicalOrOptions,
      BuiltinOptions_OneHotOptions,
      BuiltinOptions_LogicalAndOptions,
      BuiltinOptions_LogicalNotOptions,
      BuiltinOptions_UnpackOptions,
      BuiltinOptions_FloorDivOptions,
      BuiltinOptions_SquareOptions,
      BuiltinOptions_ZerosLikeOptions,
      BuiltinOptions_FillOptions,
      BuiltinOptions_BidirectionalSequenceLSTMOptions,
      BuiltinOptions_BidirectionalSequenceRNNOptions,
      BuiltinOptions_UnidirectionalSequenceLSTMOptions,
      BuiltinOptions_FloorModOptions,
      BuiltinOptions_RangeOptions,
      BuiltinOptions_ResizeNearestNeighborOptions,
      BuiltinOptions_LeakyReluOptions,
      BuiltinOptions_SquaredDifferenceOptions,
      BuiltinOptions_MirrorPadOptions,
      BuiltinOptions_AbsOptions,
      BuiltinOptions_SplitVOptions,
      BuiltinOptions_UniqueOptions,
      BuiltinOptions_ReverseV2Options,
      BuiltinOptions_AddNOptions,
      BuiltinOptions_GatherNdOptions,
      BuiltinOptions_CosOptions,
      BuiltinOptions_WhereOptions,
      BuiltinOptions_RankOptions,
      BuiltinOptions_ReverseSequenceOptions,
      BuiltinOptions_MatrixDiagOptions,
      BuiltinOptions_QuantizeOptions,
      BuiltinOptions_MatrixSetDiagOptions,
      BuiltinOptions_HardSwishOptions,
      BuiltinOptions_IfOptions,
      BuiltinOptions_WhileOptions,
      BuiltinOptions_DepthToSpaceOptions,
      BuiltinOptions_NonMaxSuppressionV4Options,
      BuiltinOptions_NonMaxSuppressionV5Options,
      BuiltinOptions_ScatterNdOptions,
      BuiltinOptions_SelectV2Options,
      BuiltinOptions_DensifyOptions,
      BuiltinOptions_SegmentSumOptions,
      BuiltinOptions_BatchMatMulOptions,
      BuiltinOptions_CumsumOptions,
      BuiltinOptions_CallOnceOptions,
      BuiltinOptions_BroadcastToOptions,
      BuiltinOptions_Rfft2dOptions,
      BuiltinOptions_Conv3DOptions,
      BuiltinOptions_HashtableOptions,
      BuiltinOptions_HashtableFindOptions,
      BuiltinOptions_HashtableImportOptions,
      BuiltinOptions_HashtableSizeOptions,
      BuiltinOptions_VarHandleOptions,
      BuiltinOptions_ReadVariableOptions,
      BuiltinOptions_AssignVariableOptions,
      BuiltinOptions_RandomOptions,
      BuiltinOptions_BucketizeOptions,
      BuiltinOptions_GeluOptions};
  return values;
}

inline const char* const* EnumNamesBuiltinOptions() {
  static const char* const names[118] = {"NONE",
                                         "Conv2DOptions",
                                         "DepthwiseConv2DOptions",
                                         "ConcatEmbeddingsOptions",
                                         "LSHProjectionOptions",
                                         "Pool2DOptions",
                                         "SVDFOptions",
                                         "RNNOptions",
                                         "FullyConnectedOptions",
                                         "SoftmaxOptions",
                                         "ConcatenationOptions",
                                         "AddOptions",
                                         "L2NormOptions",
                                         "LocalResponseNormalizationOptions",
                                         "LSTMOptions",
                                         "ResizeBilinearOptions",
                                         "CallOptions",
                                         "ReshapeOptions",
                                         "SkipGramOptions",
                                         "SpaceToDepthOptions",
                                         "EmbeddingLookupSparseOptions",
                                         "MulOptions",
                                         "PadOptions",
                                         "GatherOptions",
                                         "BatchToSpaceNDOptions",
                                         "SpaceToBatchNDOptions",
                                         "TransposeOptions",
                                         "ReducerOptions",
                                         "SubOptions",
                                         "DivOptions",
                                         "SqueezeOptions",
                                         "SequenceRNNOptions",
                                         "StridedSliceOptions",
                                         "ExpOptions",
                                         "TopKV2Options",
                                         "SplitOptions",
                                         "LogSoftmaxOptions",
                                         "CastOptions",
                                         "DequantizeOptions",
                                         "MaximumMinimumOptions",
                                         "ArgMaxOptions",
                                         "LessOptions",
                                         "NegOptions",
                                         "PadV2Options",
                                         "GreaterOptions",
                                         "GreaterEqualOptions",
                                         "LessEqualOptions",
                                         "SelectOptions",
                                         "SliceOptions",
                                         "TransposeConvOptions",
                                         "SparseToDenseOptions",
                                         "TileOptions",
                                         "ExpandDimsOptions",
                                         "EqualOptions",
                                         "NotEqualOptions",
                                         "ShapeOptions",
                                         "PowOptions",
                                         "ArgMinOptions",
                                         "FakeQuantOptions",
                                         "PackOptions",
                                         "LogicalOrOptions",
                                         "OneHotOptions",
                                         "LogicalAndOptions",
                                         "LogicalNotOptions",
                                         "UnpackOptions",
                                         "FloorDivOptions",
                                         "SquareOptions",
                                         "ZerosLikeOptions",
                                         "FillOptions",
                                         "BidirectionalSequenceLSTMOptions",
                                         "BidirectionalSequenceRNNOptions",
                                         "UnidirectionalSequenceLSTMOptions",
                                         "FloorModOptions",
                                         "RangeOptions",
                                         "ResizeNearestNeighborOptions",
                                         "LeakyReluOptions",
                                         "SquaredDifferenceOptions",
                                         "MirrorPadOptions",
                                         "AbsOptions",
                                         "SplitVOptions",
                                         "UniqueOptions",
                                         "ReverseV2Options",
                                         "AddNOptions",
                                         "GatherNdOptions",
                                         "CosOptions",
                                         "WhereOptions",
                                         "RankOptions",
                                         "ReverseSequenceOptions",
                                         "MatrixDiagOptions",
                                         "QuantizeOptions",
                                         "MatrixSetDiagOptions",
                                         "HardSwishOptions",
                                         "IfOptions",
                                         "WhileOptions",
                                         "DepthToSpaceOptions",
                                         "NonMaxSuppressionV4Options",
                                         "NonMaxSuppressionV5Options",
                                         "ScatterNdOptions",
                                         "SelectV2Options",
                                         "DensifyOptions",
                                         "SegmentSumOptions",
                                         "BatchMatMulOptions",
                                         "CumsumOptions",
                                         "CallOnceOptions",
                                         "BroadcastToOptions",
                                         "Rfft2dOptions",
                                         "Conv3DOptions",
                                         "HashtableOptions",
                                         "HashtableFindOptions",
                                         "HashtableImportOptions",
                                         "HashtableSizeOptions",
                                         "VarHandleOptions",
                                         "ReadVariableOptions",
                                         "AssignVariableOptions",
                                         "RandomOptions",
                                         "BucketizeOptions",
                                         "GeluOptions",
                                         nullptr};
  return names;
}

inline const char* EnumNameBuiltinOptions(BuiltinOptions e) {
  if (flatbuffers::IsOutRange(e, BuiltinOptions_NONE,
                              BuiltinOptions_GeluOptions))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBuiltinOptions()[index];
}

template <typename T>
struct BuiltinOptionsTraits {
  static const BuiltinOptions enum_value = BuiltinOptions_NONE;
};

template <>
struct BuiltinOptionsTraits<tflite::Conv2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Conv2DOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::DepthwiseConv2DOptions> {
  static const BuiltinOptions enum_value =
      BuiltinOptions_DepthwiseConv2DOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ConcatEmbeddingsOptions> {
  static const BuiltinOptions enum_value =
      BuiltinOptions_ConcatEmbeddingsOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LSHProjectionOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSHProjectionOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::Pool2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Pool2DOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SVDFOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SVDFOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::RNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RNNOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::FullyConnectedOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FullyConnectedOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SoftmaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SoftmaxOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ConcatenationOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatenationOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::AddOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::L2NormOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_L2NormOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LocalResponseNormalizationOptions> {
  static const BuiltinOptions enum_value =
      BuiltinOptions_LocalResponseNormalizationOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSTMOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ResizeBilinearOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeBilinearOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::CallOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CallOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ReshapeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReshapeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SkipGramOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SkipGramOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SpaceToDepthOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToDepthOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::EmbeddingLookupSparseOptions> {
  static const BuiltinOptions enum_value =
      BuiltinOptions_EmbeddingLookupSparseOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::MulOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MulOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::PadOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::GatherOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::BatchToSpaceNDOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BatchToSpaceNDOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SpaceToBatchNDOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToBatchNDOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::TransposeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ReducerOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReducerOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SubOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SubOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::DivOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DivOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SqueezeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SqueezeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SequenceRNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SequenceRNNOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::StridedSliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_StridedSliceOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ExpOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::TopKV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_TopKV2Options;
};

template <>
struct BuiltinOptionsTraits<tflite::SplitOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LogSoftmaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogSoftmaxOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::CastOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CastOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::DequantizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DequantizeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::MaximumMinimumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MaximumMinimumOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ArgMaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMaxOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LessOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::NegOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_NegOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::PadV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadV2Options;
};

template <>
struct BuiltinOptionsTraits<tflite::GreaterOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::GreaterEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterEqualOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LessEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessEqualOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SelectOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SelectOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SliceOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::TransposeConvOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeConvOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SparseToDenseOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SparseToDenseOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::TileOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TileOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ExpandDimsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpandDimsOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::EqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_EqualOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::NotEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_NotEqualOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ShapeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ShapeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::PowOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PowOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ArgMinOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMinOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::FakeQuantOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FakeQuantOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::PackOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PackOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LogicalOrOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalOrOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::OneHotOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_OneHotOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LogicalAndOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalAndOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LogicalNotOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalNotOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::UnpackOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnpackOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::FloorDivOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorDivOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SquareOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquareOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ZerosLikeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ZerosLikeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::FillOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FillOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::BidirectionalSequenceLSTMOptions> {
  static const BuiltinOptions enum_value =
      BuiltinOptions_BidirectionalSequenceLSTMOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::BidirectionalSequenceRNNOptions> {
  static const BuiltinOptions enum_value =
      BuiltinOptions_BidirectionalSequenceRNNOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::UnidirectionalSequenceLSTMOptions> {
  static const BuiltinOptions enum_value =
      BuiltinOptions_UnidirectionalSequenceLSTMOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::FloorModOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorModOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::RangeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RangeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ResizeNearestNeighborOptions> {
  static const BuiltinOptions enum_value =
      BuiltinOptions_ResizeNearestNeighborOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::LeakyReluOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LeakyReluOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SquaredDifferenceOptions> {
  static const BuiltinOptions enum_value =
      BuiltinOptions_SquaredDifferenceOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::MirrorPadOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MirrorPadOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::AbsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AbsOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SplitVOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitVOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::UniqueOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UniqueOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ReverseV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseV2Options;
};

template <>
struct BuiltinOptionsTraits<tflite::AddNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddNOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::GatherNdOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherNdOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::CosOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CosOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::WhereOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_WhereOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::RankOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RankOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ReverseSequenceOptions> {
  static const BuiltinOptions enum_value =
      BuiltinOptions_ReverseSequenceOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::MatrixDiagOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixDiagOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::QuantizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_QuantizeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::MatrixSetDiagOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixSetDiagOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::HardSwishOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HardSwishOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::IfOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_IfOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::WhileOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_WhileOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::DepthToSpaceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DepthToSpaceOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::NonMaxSuppressionV4Options> {
  static const BuiltinOptions enum_value =
      BuiltinOptions_NonMaxSuppressionV4Options;
};

template <>
struct BuiltinOptionsTraits<tflite::NonMaxSuppressionV5Options> {
  static const BuiltinOptions enum_value =
      BuiltinOptions_NonMaxSuppressionV5Options;
};

template <>
struct BuiltinOptionsTraits<tflite::ScatterNdOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ScatterNdOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SelectV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_SelectV2Options;
};

template <>
struct BuiltinOptionsTraits<tflite::DensifyOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DensifyOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::SegmentSumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SegmentSumOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::BatchMatMulOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BatchMatMulOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::CumsumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CumsumOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::CallOnceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CallOnceOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::BroadcastToOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BroadcastToOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::Rfft2dOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Rfft2dOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::Conv3DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Conv3DOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::HashtableOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::HashtableFindOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableFindOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::HashtableImportOptions> {
  static const BuiltinOptions enum_value =
      BuiltinOptions_HashtableImportOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::HashtableSizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableSizeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::VarHandleOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_VarHandleOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::ReadVariableOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReadVariableOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::AssignVariableOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AssignVariableOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::RandomOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RandomOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::BucketizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BucketizeOptions;
};

template <>
struct BuiltinOptionsTraits<tflite::GeluOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GeluOptions;
};

bool VerifyBuiltinOptions(flatbuffers::Verifier& verifier, const void* obj,
                          BuiltinOptions type);
bool VerifyBuiltinOptionsVector(
    flatbuffers::Verifier& verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
    const flatbuffers::Vector<uint8_t>* types);

enum Padding {
  Padding_SAME = 0,
  Padding_VALID = 1,
  Padding_MIN = Padding_SAME,
  Padding_MAX = Padding_VALID
};

inline const Padding (&EnumValuesPadding())[2] {
  static const Padding values[] = {Padding_SAME, Padding_VALID};
  return values;
}

inline const char* const* EnumNamesPadding() {
  static const char* const names[3] = {"SAME", "VALID", nullptr};
  return names;
}

inline const char* EnumNamePadding(Padding e) {
  if (flatbuffers::IsOutRange(e, Padding_SAME, Padding_VALID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadding()[index];
}

enum ActivationFunctionType {
  ActivationFunctionType_NONE = 0,
  ActivationFunctionType_RELU = 1,
  ActivationFunctionType_RELU_N1_TO_1 = 2,
  ActivationFunctionType_RELU6 = 3,
  ActivationFunctionType_TANH = 4,
  ActivationFunctionType_SIGN_BIT = 5,
  ActivationFunctionType_MIN = ActivationFunctionType_NONE,
  ActivationFunctionType_MAX = ActivationFunctionType_SIGN_BIT
};

inline const ActivationFunctionType (&EnumValuesActivationFunctionType())[6] {
  static const ActivationFunctionType values[] = {
      ActivationFunctionType_NONE,         ActivationFunctionType_RELU,
      ActivationFunctionType_RELU_N1_TO_1, ActivationFunctionType_RELU6,
      ActivationFunctionType_TANH,         ActivationFunctionType_SIGN_BIT};
  return values;
}

inline const char* const* EnumNamesActivationFunctionType() {
  static const char* const names[7] = {
      "NONE", "RELU", "RELU_N1_TO_1", "RELU6", "TANH", "SIGN_BIT", nullptr};
  return names;
}

inline const char* EnumNameActivationFunctionType(ActivationFunctionType e) {
  if (flatbuffers::IsOutRange(e, ActivationFunctionType_NONE,
                              ActivationFunctionType_SIGN_BIT))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationFunctionType()[index];
}

enum LSHProjectionType {
  LSHProjectionType_UNKNOWN = 0,
  LSHProjectionType_SPARSE = 1,
  LSHProjectionType_DENSE = 2,
  LSHProjectionType_MIN = LSHProjectionType_UNKNOWN,
  LSHProjectionType_MAX = LSHProjectionType_DENSE
};

inline const LSHProjectionType (&EnumValuesLSHProjectionType())[3] {
  static const LSHProjectionType values[] = {LSHProjectionType_UNKNOWN,
                                             LSHProjectionType_SPARSE,
                                             LSHProjectionType_DENSE};
  return values;
}

inline const char* const* EnumNamesLSHProjectionType() {
  static const char* const names[4] = {"UNKNOWN", "SPARSE", "DENSE", nullptr};
  return names;
}

inline const char* EnumNameLSHProjectionType(LSHProjectionType e) {
  if (flatbuffers::IsOutRange(e, LSHProjectionType_UNKNOWN,
                              LSHProjectionType_DENSE))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSHProjectionType()[index];
}

enum FullyConnectedOptionsWeightsFormat {
  FullyConnectedOptionsWeightsFormat_DEFAULT = 0,
  FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8 = 1,
  FullyConnectedOptionsWeightsFormat_MIN =
      FullyConnectedOptionsWeightsFormat_DEFAULT,
  FullyConnectedOptionsWeightsFormat_MAX =
      FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
};

inline const FullyConnectedOptionsWeightsFormat (
    &EnumValuesFullyConnectedOptionsWeightsFormat())[2] {
  static const FullyConnectedOptionsWeightsFormat values[] = {
      FullyConnectedOptionsWeightsFormat_DEFAULT,
      FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8};
  return values;
}

inline const char* const* EnumNamesFullyConnectedOptionsWeightsFormat() {
  static const char* const names[3] = {"DEFAULT", "SHUFFLED4x16INT8", nullptr};
  return names;
}

inline const char* EnumNameFullyConnectedOptionsWeightsFormat(
    FullyConnectedOptionsWeightsFormat e) {
  if (flatbuffers::IsOutRange(
          e, FullyConnectedOptionsWeightsFormat_DEFAULT,
          FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFullyConnectedOptionsWeightsFormat()[index];
}

enum LSTMKernelType {
  LSTMKernelType_FULL = 0,
  LSTMKernelType_BASIC = 1,
  LSTMKernelType_MIN = LSTMKernelType_FULL,
  LSTMKernelType_MAX = LSTMKernelType_BASIC
};

inline const LSTMKernelType (&EnumValuesLSTMKernelType())[2] {
  static const LSTMKernelType values[] = {LSTMKernelType_FULL,
                                          LSTMKernelType_BASIC};
  return values;
}

inline const char* const* EnumNamesLSTMKernelType() {
  static const char* const names[3] = {"FULL", "BASIC", nullptr};
  return names;
}

inline const char* EnumNameLSTMKernelType(LSTMKernelType e) {
  if (flatbuffers::IsOutRange(e, LSTMKernelType_FULL, LSTMKernelType_BASIC))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSTMKernelType()[index];
}

enum CombinerType {
  CombinerType_SUM = 0,
  CombinerType_MEAN = 1,
  CombinerType_SQRTN = 2,
  CombinerType_MIN = CombinerType_SUM,
  CombinerType_MAX = CombinerType_SQRTN
};

inline const CombinerType (&EnumValuesCombinerType())[3] {
  static const CombinerType values[] = {CombinerType_SUM, CombinerType_MEAN,
                                        CombinerType_SQRTN};
  return values;
}

inline const char* const* EnumNamesCombinerType() {
  static const char* const names[4] = {"SUM", "MEAN", "SQRTN", nullptr};
  return names;
}

inline const char* EnumNameCombinerType(CombinerType e) {
  if (flatbuffers::IsOutRange(e, CombinerType_SUM, CombinerType_SQRTN))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCombinerType()[index];
}

enum MirrorPadMode {
  MirrorPadMode_REFLECT = 0,
  MirrorPadMode_SYMMETRIC = 1,
  MirrorPadMode_MIN = MirrorPadMode_REFLECT,
  MirrorPadMode_MAX = MirrorPadMode_SYMMETRIC
};

inline const MirrorPadMode (&EnumValuesMirrorPadMode())[2] {
  static const MirrorPadMode values[] = {MirrorPadMode_REFLECT,
                                         MirrorPadMode_SYMMETRIC};
  return values;
}

inline const char* const* EnumNamesMirrorPadMode() {
  static const char* const names[3] = {"REFLECT", "SYMMETRIC", nullptr};
  return names;
}

inline const char* EnumNameMirrorPadMode(MirrorPadMode e) {
  if (flatbuffers::IsOutRange(e, MirrorPadMode_REFLECT,
                              MirrorPadMode_SYMMETRIC))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMirrorPadMode()[index];
}

enum CustomOptionsFormat {
  CustomOptionsFormat_FLEXBUFFERS = 0,
  CustomOptionsFormat_MIN = CustomOptionsFormat_FLEXBUFFERS,
  CustomOptionsFormat_MAX = CustomOptionsFormat_FLEXBUFFERS
};

inline const CustomOptionsFormat (&EnumValuesCustomOptionsFormat())[1] {
  static const CustomOptionsFormat values[] = {CustomOptionsFormat_FLEXBUFFERS};
  return values;
}

inline const char* const* EnumNamesCustomOptionsFormat() {
  static const char* const names[2] = {"FLEXBUFFERS", nullptr};
  return names;
}

inline const char* EnumNameCustomOptionsFormat(CustomOptionsFormat e) {
  if (flatbuffers::IsOutRange(e, CustomOptionsFormat_FLEXBUFFERS,
                              CustomOptionsFormat_FLEXBUFFERS))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCustomOptionsFormat()[index];
}

struct CustomQuantization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return CustomQuantizationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CUSTOM = 4
  };
  const flatbuffers::Vector<uint8_t>* custom() const {
    return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_CUSTOM);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_CUSTOM) &&
           verifier.VerifyVector(custom()) && verifier.EndTable();
  }
};

struct CustomQuantizationBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_custom(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom) {
    fbb_.AddOffset(CustomQuantization::VT_CUSTOM, custom);
  }
  explicit CustomQuantizationBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomQuantizationBuilder& operator=(const CustomQuantizationBuilder&);
  flatbuffers::Offset<CustomQuantization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomQuantization>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom = 0) {
  CustomQuantizationBuilder builder_(_fbb);
  builder_.add_custom(custom);
  return builder_.Finish();
}

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantizationDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<uint8_t>* custom = nullptr) {
  if (custom) {
    _fbb.ForceVectorAlignment(custom->size(), sizeof(uint8_t), 16);
  }
  auto custom__ = custom ? _fbb.CreateVector<uint8_t>(*custom) : 0;
  return tflite::CreateCustomQuantization(_fbb, custom__);
}

struct QuantizationParameters FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return QuantizationParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_SCALE = 8,
    VT_ZERO_POINT = 10,
    VT_DETAILS_TYPE = 12,
    VT_DETAILS = 14,
    VT_QUANTIZED_DIMENSION = 16
  };
  const flatbuffers::Vector<float>* min() const {
    return GetPointer<const flatbuffers::Vector<float>*>(VT_MIN);
  }
  const flatbuffers::Vector<float>* max() const {
    return GetPointer<const flatbuffers::Vector<float>*>(VT_MAX);
  }
  const flatbuffers::Vector<float>* scale() const {
    return GetPointer<const flatbuffers::Vector<float>*>(VT_SCALE);
  }
  const flatbuffers::Vector<int64_t>* zero_point() const {
    return GetPointer<const flatbuffers::Vector<int64_t>*>(VT_ZERO_POINT);
  }
  tflite::QuantizationDetails details_type() const {
    return static_cast<tflite::QuantizationDetails>(
        GetField<uint8_t>(VT_DETAILS_TYPE, 0));
  }
  const void* details() const { return GetPointer<const void*>(VT_DETAILS); }
  template <typename T>
  const T* details_as() const;
  const tflite::CustomQuantization* details_as_CustomQuantization() const {
    return details_type() == tflite::QuantizationDetails_CustomQuantization
               ? static_cast<const tflite::CustomQuantization*>(details())
               : nullptr;
  }
  int32_t quantized_dimension() const {
    return GetField<int32_t>(VT_QUANTIZED_DIMENSION, 0);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_MIN) &&
           verifier.VerifyVector(min()) && VerifyOffset(verifier, VT_MAX) &&
           verifier.VerifyVector(max()) && VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyOffset(verifier, VT_ZERO_POINT) &&
           verifier.VerifyVector(zero_point()) &&
           VerifyField<uint8_t>(verifier, VT_DETAILS_TYPE) &&
           VerifyOffset(verifier, VT_DETAILS) &&
           VerifyQuantizationDetails(verifier, details(), details_type()) &&
           VerifyField<int32_t>(verifier, VT_QUANTIZED_DIMENSION) &&
           verifier.EndTable();
  }
};

template <>
inline const tflite::CustomQuantization*
QuantizationParameters::details_as<tflite::CustomQuantization>() const {
  return details_as_CustomQuantization();
}

struct QuantizationParametersBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(flatbuffers::Offset<flatbuffers::Vector<float>> min) {
    fbb_.AddOffset(QuantizationParameters::VT_MIN, min);
  }
  void add_max(flatbuffers::Offset<flatbuffers::Vector<float>> max) {
    fbb_.AddOffset(QuantizationParameters::VT_MAX, max);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(QuantizationParameters::VT_SCALE, scale);
  }
  void add_zero_point(
      flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point) {
    fbb_.AddOffset(QuantizationParameters::VT_ZERO_POINT, zero_point);
  }
  void add_details_type(tflite::QuantizationDetails details_type) {
    fbb_.AddElement<uint8_t>(QuantizationParameters::VT_DETAILS_TYPE,
                             static_cast<uint8_t>(details_type), 0);
  }
  void add_details(flatbuffers::Offset<void> details) {
    fbb_.AddOffset(QuantizationParameters::VT_DETAILS, details);
  }
  void add_quantized_dimension(int32_t quantized_dimension) {
    fbb_.AddElement<int32_t>(QuantizationParameters::VT_QUANTIZED_DIMENSION,
                             quantized_dimension, 0);
  }
  explicit QuantizationParametersBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizationParametersBuilder& operator=(
      const QuantizationParametersBuilder&);
  flatbuffers::Offset<QuantizationParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizationParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> min = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> max = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point = 0,
    tflite::QuantizationDetails details_type = tflite::QuantizationDetails_NONE,
    flatbuffers::Offset<void> details = 0, int32_t quantized_dimension = 0) {
  QuantizationParametersBuilder builder_(_fbb);
  builder_.add_quantized_dimension(quantized_dimension);
  builder_.add_details(details);
  builder_.add_zero_point(zero_point);
  builder_.add_scale(scale);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_details_type(details_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuantizationParameters>
CreateQuantizationParametersDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<float>* min = nullptr,
    const std::vector<float>* max = nullptr,
    const std::vector<float>* scale = nullptr,
    const std::vector<int64_t>* zero_point = nullptr,
    tflite::QuantizationDetails details_type = tflite::QuantizationDetails_NONE,
    flatbuffers::Offset<void> details = 0, int32_t quantized_dimension = 0) {
  auto min__ = min ? _fbb.CreateVector<float>(*min) : 0;
  auto max__ = max ? _fbb.CreateVector<float>(*max) : 0;
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  auto zero_point__ = zero_point ? _fbb.CreateVector<int64_t>(*zero_point) : 0;
  return tflite::CreateQuantizationParameters(_fbb, min__, max__, scale__,
                                              zero_point__, details_type,
                                              details, quantized_dimension);
}

struct Int32Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return Int32VectorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<int32_t>* values() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) && verifier.EndTable();
  }
};

struct Int32VectorBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<int32_t>> values) {
    fbb_.AddOffset(Int32Vector::VT_VALUES, values);
  }
  explicit Int32VectorBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int32VectorBuilder& operator=(const Int32VectorBuilder&);
  flatbuffers::Offset<Int32Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int32Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int32Vector> CreateInt32Vector(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> values = 0) {
  Int32VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<Int32Vector> CreateInt32VectorDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<int32_t>* values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<int32_t>(*values) : 0;
  return tflite::CreateInt32Vector(_fbb, values__);
}

struct Uint16Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return Uint16VectorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<uint16_t>* values() const {
    return GetPointer<const flatbuffers::Vector<uint16_t>*>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) && verifier.EndTable();
  }
};

struct Uint16VectorBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> values) {
    fbb_.AddOffset(Uint16Vector::VT_VALUES, values);
  }
  explicit Uint16VectorBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Uint16VectorBuilder& operator=(const Uint16VectorBuilder&);
  flatbuffers::Offset<Uint16Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint16Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint16Vector> CreateUint16Vector(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> values = 0) {
  Uint16VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<Uint16Vector> CreateUint16VectorDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<uint16_t>* values = nullptr) {
  if (values) {
    _fbb.ForceVectorAlignment(values->size(), sizeof(uint16_t), 4);
  }
  auto values__ = values ? _fbb.CreateVector<uint16_t>(*values) : 0;
  return tflite::CreateUint16Vector(_fbb, values__);
}

struct Uint8Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return Uint8VectorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<uint8_t>* values() const {
    return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) && verifier.EndTable();
  }
};

struct Uint8VectorBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values) {
    fbb_.AddOffset(Uint8Vector::VT_VALUES, values);
  }
  explicit Uint8VectorBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Uint8VectorBuilder& operator=(const Uint8VectorBuilder&);
  flatbuffers::Offset<Uint8Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint8Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint8Vector> CreateUint8Vector(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values = 0) {
  Uint8VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<Uint8Vector> CreateUint8VectorDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<uint8_t>* values = nullptr) {
  if (values) {
    _fbb.ForceVectorAlignment(values->size(), sizeof(uint8_t), 4);
  }
  auto values__ = values ? _fbb.CreateVector<uint8_t>(*values) : 0;
  return tflite::CreateUint8Vector(_fbb, values__);
}

struct DimensionMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return DimensionMetadataTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_DENSE_SIZE = 6,
    VT_ARRAY_SEGMENTS_TYPE = 8,
    VT_ARRAY_SEGMENTS = 10,
    VT_ARRAY_INDICES_TYPE = 12,
    VT_ARRAY_INDICES = 14
  };
  tflite::DimensionType format() const {
    return static_cast<tflite::DimensionType>(GetField<int8_t>(VT_FORMAT, 0));
  }
  int32_t dense_size() const { return GetField<int32_t>(VT_DENSE_SIZE, 0); }
  tflite::SparseIndexVector array_segments_type() const {
    return static_cast<tflite::SparseIndexVector>(
        GetField<uint8_t>(VT_ARRAY_SEGMENTS_TYPE, 0));
  }
  const void* array_segments() const {
    return GetPointer<const void*>(VT_ARRAY_SEGMENTS);
  }
  template <typename T>
  const T* array_segments_as() const;
  const tflite::Int32Vector* array_segments_as_Int32Vector() const {
    return array_segments_type() == tflite::SparseIndexVector_Int32Vector
               ? static_cast<const tflite::Int32Vector*>(array_segments())
               : nullptr;
  }
  const tflite::Uint16Vector* array_segments_as_Uint16Vector() const {
    return array_segments_type() == tflite::SparseIndexVector_Uint16Vector
               ? static_cast<const tflite::Uint16Vector*>(array_segments())
               : nullptr;
  }
  const tflite::Uint8Vector* array_segments_as_Uint8Vector() const {
    return array_segments_type() == tflite::SparseIndexVector_Uint8Vector
               ? static_cast<const tflite::Uint8Vector*>(array_segments())
               : nullptr;
  }
  tflite::SparseIndexVector array_indices_type() const {
    return static_cast<tflite::SparseIndexVector>(
        GetField<uint8_t>(VT_ARRAY_INDICES_TYPE, 0));
  }
  const void* array_indices() const {
    return GetPointer<const void*>(VT_ARRAY_INDICES);
  }
  template <typename T>
  const T* array_indices_as() const;
  const tflite::Int32Vector* array_indices_as_Int32Vector() const {
    return array_indices_type() == tflite::SparseIndexVector_Int32Vector
               ? static_cast<const tflite::Int32Vector*>(array_indices())
               : nullptr;
  }
  const tflite::Uint16Vector* array_indices_as_Uint16Vector() const {
    return array_indices_type() == tflite::SparseIndexVector_Uint16Vector
               ? static_cast<const tflite::Uint16Vector*>(array_indices())
               : nullptr;
  }
  const tflite::Uint8Vector* array_indices_as_Uint8Vector() const {
    return array_indices_type() == tflite::SparseIndexVector_Uint8Vector
               ? static_cast<const tflite::Uint8Vector*>(array_indices())
               : nullptr;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_DENSE_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_ARRAY_SEGMENTS_TYPE) &&
           VerifyOffset(verifier, VT_ARRAY_SEGMENTS) &&
           VerifySparseIndexVector(verifier, array_segments(),
                                   array_segments_type()) &&
           VerifyField<uint8_t>(verifier, VT_ARRAY_INDICES_TYPE) &&
           VerifyOffset(verifier, VT_ARRAY_INDICES) &&
           VerifySparseIndexVector(verifier, array_indices(),
                                   array_indices_type()) &&
           verifier.EndTable();
  }
};

template <>
inline const tflite::Int32Vector*
DimensionMetadata::array_segments_as<tflite::Int32Vector>() const {
  return array_segments_as_Int32Vector();
}

template <>
inline const tflite::Uint16Vector*
DimensionMetadata::array_segments_as<tflite::Uint16Vector>() const {
  return array_segments_as_Uint16Vector();
}

template <>
inline const tflite::Uint8Vector*
DimensionMetadata::array_segments_as<tflite::Uint8Vector>() const {
  return array_segments_as_Uint8Vector();
}

template <>
inline const tflite::Int32Vector*
DimensionMetadata::array_indices_as<tflite::Int32Vector>() const {
  return array_indices_as_Int32Vector();
}

template <>
inline const tflite::Uint16Vector*
DimensionMetadata::array_indices_as<tflite::Uint16Vector>() const {
  return array_indices_as_Uint16Vector();
}

template <>
inline const tflite::Uint8Vector*
DimensionMetadata::array_indices_as<tflite::Uint8Vector>() const {
  return array_indices_as_Uint8Vector();
}

struct DimensionMetadataBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(tflite::DimensionType format) {
    fbb_.AddElement<int8_t>(DimensionMetadata::VT_FORMAT,
                            static_cast<int8_t>(format), 0);
  }
  void add_dense_size(int32_t dense_size) {
    fbb_.AddElement<int32_t>(DimensionMetadata::VT_DENSE_SIZE, dense_size, 0);
  }
  void add_array_segments_type(tflite::SparseIndexVector array_segments_type) {
    fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_SEGMENTS_TYPE,
                             static_cast<uint8_t>(array_segments_type), 0);
  }
  void add_array_segments(flatbuffers::Offset<void> array_segments) {
    fbb_.AddOffset(DimensionMetadata::VT_ARRAY_SEGMENTS, array_segments);
  }
  void add_array_indices_type(tflite::SparseIndexVector array_indices_type) {
    fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_INDICES_TYPE,
                             static_cast<uint8_t>(array_indices_type), 0);
  }
  void add_array_indices(flatbuffers::Offset<void> array_indices) {
    fbb_.AddOffset(DimensionMetadata::VT_ARRAY_INDICES, array_indices);
  }
  explicit DimensionMetadataBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionMetadataBuilder& operator=(const DimensionMetadataBuilder&);
  flatbuffers::Offset<DimensionMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::DimensionType format = tflite::DimensionType_DENSE,
    int32_t dense_size = 0,
    tflite::SparseIndexVector array_segments_type =
        tflite::SparseIndexVector_NONE,
    flatbuffers::Offset<void> array_segments = 0,
    tflite::SparseIndexVector array_indices_type =
        tflite::SparseIndexVector_NONE,
    flatbuffers::Offset<void> array_indices = 0) {
  DimensionMetadataBuilder builder_(_fbb);
  builder_.add_array_indices(array_indices);
  builder_.add_array_segments(array_segments);
  builder_.add_dense_size(dense_size);
  builder_.add_array_indices_type(array_indices_type);
  builder_.add_array_segments_type(array_segments_type);
  builder_.add_format(format);
  return builder_.Finish();
}

struct SparsityParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SparsityParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRAVERSAL_ORDER = 4,
    VT_BLOCK_MAP = 6,
    VT_DIM_METADATA = 8
  };
  const flatbuffers::Vector<int32_t>* traversal_order() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_TRAVERSAL_ORDER);
  }
  const flatbuffers::Vector<int32_t>* block_map() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_BLOCK_MAP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>>*
  dim_metadata() const {
    return GetPointer<const flatbuffers::Vector<
        flatbuffers::Offset<tflite::DimensionMetadata>>*>(VT_DIM_METADATA);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRAVERSAL_ORDER) &&
           verifier.VerifyVector(traversal_order()) &&
           VerifyOffset(verifier, VT_BLOCK_MAP) &&
           verifier.VerifyVector(block_map()) &&
           VerifyOffset(verifier, VT_DIM_METADATA) &&
           verifier.VerifyVector(dim_metadata()) &&
           verifier.VerifyVectorOfTables(dim_metadata()) && verifier.EndTable();
  }
};

struct SparsityParametersBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_traversal_order(
      flatbuffers::Offset<flatbuffers::Vector<int32_t>> traversal_order) {
    fbb_.AddOffset(SparsityParameters::VT_TRAVERSAL_ORDER, traversal_order);
  }
  void add_block_map(
      flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_map) {
    fbb_.AddOffset(SparsityParameters::VT_BLOCK_MAP, block_map);
  }
  void add_dim_metadata(
      flatbuffers::Offset<
          flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>>>
          dim_metadata) {
    fbb_.AddOffset(SparsityParameters::VT_DIM_METADATA, dim_metadata);
  }
  explicit SparsityParametersBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparsityParametersBuilder& operator=(const SparsityParametersBuilder&);
  flatbuffers::Offset<SparsityParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparsityParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> traversal_order = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_map = 0,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<tflite::DimensionMetadata>>>
        dim_metadata = 0) {
  SparsityParametersBuilder builder_(_fbb);
  builder_.add_dim_metadata(dim_metadata);
  builder_.add_block_map(block_map);
  builder_.add_traversal_order(traversal_order);
  return builder_.Finish();
}

inline flatbuffers::Offset<SparsityParameters> CreateSparsityParametersDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<int32_t>* traversal_order = nullptr,
    const std::vector<int32_t>* block_map = nullptr,
    const std::vector<flatbuffers::Offset<tflite::DimensionMetadata>>*
        dim_metadata = nullptr) {
  auto traversal_order__ =
      traversal_order ? _fbb.CreateVector<int32_t>(*traversal_order) : 0;
  auto block_map__ = block_map ? _fbb.CreateVector<int32_t>(*block_map) : 0;
  auto dim_metadata__ =
      dim_metadata
          ? _fbb.CreateVector<flatbuffers::Offset<tflite::DimensionMetadata>>(
                *dim_metadata)
          : 0;
  return tflite::CreateSparsityParameters(_fbb, traversal_order__, block_map__,
                                          dim_metadata__);
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return TensorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_TYPE = 6,
    VT_BUFFER = 8,
    VT_NAME = 10,
    VT_QUANTIZATION = 12,
    VT_IS_VARIABLE = 14,
    VT_SPARSITY = 16,
    VT_SHAPE_SIGNATURE = 18
  };
  const flatbuffers::Vector<int32_t>* shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_SHAPE);
  }
  tflite::TensorType type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint32_t buffer() const { return GetField<uint32_t>(VT_BUFFER, 0); }
  const flatbuffers::String* name() const {
    return GetPointer<const flatbuffers::String*>(VT_NAME);
  }
  const tflite::QuantizationParameters* quantization() const {
    return GetPointer<const tflite::QuantizationParameters*>(VT_QUANTIZATION);
  }
  bool is_variable() const { return GetField<uint8_t>(VT_IS_VARIABLE, 0) != 0; }
  const tflite::SparsityParameters* sparsity() const {
    return GetPointer<const tflite::SparsityParameters*>(VT_SPARSITY);
  }
  const flatbuffers::Vector<int32_t>* shape_signature() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_SHAPE_SIGNATURE);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER) &&
           VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_QUANTIZATION) &&
           verifier.VerifyTable(quantization()) &&
           VerifyField<uint8_t>(verifier, VT_IS_VARIABLE) &&
           VerifyOffset(verifier, VT_SPARSITY) &&
           verifier.VerifyTable(sparsity()) &&
           VerifyOffset(verifier, VT_SHAPE_SIGNATURE) &&
           verifier.VerifyVector(shape_signature()) && verifier.EndTable();
  }
};

struct TensorBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_type(tflite::TensorType type) {
    fbb_.AddElement<int8_t>(Tensor::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_buffer(uint32_t buffer) {
    fbb_.AddElement<uint32_t>(Tensor::VT_BUFFER, buffer, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_quantization(
      flatbuffers::Offset<tflite::QuantizationParameters> quantization) {
    fbb_.AddOffset(Tensor::VT_QUANTIZATION, quantization);
  }
  void add_is_variable(bool is_variable) {
    fbb_.AddElement<uint8_t>(Tensor::VT_IS_VARIABLE,
                             static_cast<uint8_t>(is_variable), 0);
  }
  void add_sparsity(flatbuffers::Offset<tflite::SparsityParameters> sparsity) {
    fbb_.AddOffset(Tensor::VT_SPARSITY, sparsity);
  }
  void add_shape_signature(
      flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape_signature) {
    fbb_.AddOffset(Tensor::VT_SHAPE_SIGNATURE, shape_signature);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder& operator=(const TensorBuilder&);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,
    tflite::TensorType type = tflite::TensorType_FLOAT32, uint32_t buffer = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0,
    bool is_variable = false,
    flatbuffers::Offset<tflite::SparsityParameters> sparsity = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape_signature = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_shape_signature(shape_signature);
  builder_.add_sparsity(sparsity);
  builder_.add_quantization(quantization);
  builder_.add_name(name);
  builder_.add_buffer(buffer);
  builder_.add_shape(shape);
  builder_.add_is_variable(is_variable);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<int32_t>* shape = nullptr,
    tflite::TensorType type = tflite::TensorType_FLOAT32, uint32_t buffer = 0,
    const char* name = nullptr,
    flatbuffers::Offset<tflite::QuantizationParameters> quantization = 0,
    bool is_variable = false,
    flatbuffers::Offset<tflite::SparsityParameters> sparsity = 0,
    const std::vector<int32_t>* shape_signature = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto shape_signature__ =
      shape_signature ? _fbb.CreateVector<int32_t>(*shape_signature) : 0;
  return tflite::CreateTensor(_fbb, shape__, type, buffer, name__, quantization,
                              is_variable, sparsity, shape_signature__);
}

struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return Conv2DOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FUSED_ACTIVATION_FUNCTION = 10,
    VT_DILATION_W_FACTOR = 12,
    VT_DILATION_H_FACTOR = 14
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) &&
           verifier.EndTable();
  }
};

struct Conv2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_PADDING,
                            static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_W_FACTOR,
                             dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_H_FACTOR,
                             dilation_h_factor, 1);
  }
  explicit Conv2DOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DOptionsBuilder& operator=(const Conv2DOptionsBuilder&);
  flatbuffers::Offset<Conv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::Padding padding = tflite::Padding_SAME, int32_t stride_w = 0,
    int32_t stride_h = 0,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1, int32_t dilation_h_factor = 1) {
  Conv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct Conv3DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return Conv3DOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_D = 6,
    VT_STRIDE_W = 8,
    VT_STRIDE_H = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_DILATION_D_FACTOR = 14,
    VT_DILATION_W_FACTOR = 16,
    VT_DILATION_H_FACTOR = 18
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_d() const { return GetField<int32_t>(VT_STRIDE_D, 0); }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_d_factor() const {
    return GetField<int32_t>(VT_DILATION_D_FACTOR, 1);
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_D) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_D_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) &&
           verifier.EndTable();
  }
};

struct Conv3DOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(Conv3DOptions::VT_PADDING,
                            static_cast<int8_t>(padding), 0);
  }
  void add_stride_d(int32_t stride_d) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_D, stride_d, 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Conv3DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_d_factor(int32_t dilation_d_factor) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_D_FACTOR,
                             dilation_d_factor, 1);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_W_FACTOR,
                             dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_H_FACTOR,
                             dilation_h_factor, 1);
  }
  explicit Conv3DOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv3DOptionsBuilder& operator=(const Conv3DOptionsBuilder&);
  flatbuffers::Offset<Conv3DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv3DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::Padding padding = tflite::Padding_SAME, int32_t stride_d = 0,
    int32_t stride_w = 0, int32_t stride_h = 0,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE,
    int32_t dilation_d_factor = 1, int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1) {
  Conv3DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_dilation_d_factor(dilation_d_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_stride_d(stride_d);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct Pool2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return Pool2DOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FILTER_WIDTH = 10,
    VT_FILTER_HEIGHT = 12,
    VT_FUSED_ACTIVATION_FUNCTION = 14
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  int32_t filter_width() const { return GetField<int32_t>(VT_FILTER_WIDTH, 0); }
  int32_t filter_height() const {
    return GetField<int32_t>(VT_FILTER_HEIGHT, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int32_t>(verifier, VT_FILTER_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_FILTER_HEIGHT) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct Pool2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_PADDING,
                            static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_filter_width(int32_t filter_width) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_WIDTH, filter_width, 0);
  }
  void add_filter_height(int32_t filter_height) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_HEIGHT, filter_height, 0);
  }
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit Pool2DOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Pool2DOptionsBuilder& operator=(const Pool2DOptionsBuilder&);
  flatbuffers::Offset<Pool2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::Padding padding = tflite::Padding_SAME, int32_t stride_w = 0,
    int32_t stride_h = 0, int32_t filter_width = 0, int32_t filter_height = 0,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE) {
  Pool2DOptionsBuilder builder_(_fbb);
  builder_.add_filter_height(filter_height);
  builder_.add_filter_width(filter_width);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct DepthwiseConv2DOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return DepthwiseConv2DOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_DEPTH_MULTIPLIER = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_DILATION_W_FACTOR = 14,
    VT_DILATION_H_FACTOR = 16
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  int32_t depth_multiplier() const {
    return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0);
  }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) &&
           verifier.EndTable();
  }
};

struct DepthwiseConv2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_PADDING,
                            static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_depth_multiplier(int32_t depth_multiplier) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER,
                             depth_multiplier, 0);
  }
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(
        DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
        static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR,
                             dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR,
                             dilation_h_factor, 1);
  }
  explicit DepthwiseConv2DOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthwiseConv2DOptionsBuilder& operator=(
      const DepthwiseConv2DOptionsBuilder&);
  flatbuffers::Offset<DepthwiseConv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthwiseConv2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::Padding padding = tflite::Padding_SAME, int32_t stride_w = 0,
    int32_t stride_h = 0, int32_t depth_multiplier = 0,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1, int32_t dilation_h_factor = 1) {
  DepthwiseConv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_depth_multiplier(depth_multiplier);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct ConcatEmbeddingsOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ConcatEmbeddingsOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_CHANNELS = 4,
    VT_NUM_COLUMNS_PER_CHANNEL = 6,
    VT_EMBEDDING_DIM_PER_CHANNEL = 8
  };
  int32_t num_channels() const { return GetField<int32_t>(VT_NUM_CHANNELS, 0); }
  const flatbuffers::Vector<int32_t>* num_columns_per_channel() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(
        VT_NUM_COLUMNS_PER_CHANNEL);
  }
  const flatbuffers::Vector<int32_t>* embedding_dim_per_channel() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(
        VT_EMBEDDING_DIM_PER_CHANNEL);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_CHANNELS) &&
           VerifyOffset(verifier, VT_NUM_COLUMNS_PER_CHANNEL) &&
           verifier.VerifyVector(num_columns_per_channel()) &&
           VerifyOffset(verifier, VT_EMBEDDING_DIM_PER_CHANNEL) &&
           verifier.VerifyVector(embedding_dim_per_channel()) &&
           verifier.EndTable();
  }
};

struct ConcatEmbeddingsOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_channels(int32_t num_channels) {
    fbb_.AddElement<int32_t>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS,
                             num_channels, 0);
  }
  void add_num_columns_per_channel(
      flatbuffers::Offset<flatbuffers::Vector<int32_t>>
          num_columns_per_channel) {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL,
                   num_columns_per_channel);
  }
  void add_embedding_dim_per_channel(
      flatbuffers::Offset<flatbuffers::Vector<int32_t>>
          embedding_dim_per_channel) {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL,
                   embedding_dim_per_channel);
  }
  explicit ConcatEmbeddingsOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatEmbeddingsOptionsBuilder& operator=(
      const ConcatEmbeddingsOptionsBuilder&);
  flatbuffers::Offset<ConcatEmbeddingsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatEmbeddingsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatEmbeddingsOptions>
CreateConcatEmbeddingsOptions(flatbuffers::FlatBufferBuilder& _fbb,
                              int32_t num_channels = 0,
                              flatbuffers::Offset<flatbuffers::Vector<int32_t>>
                                  num_columns_per_channel = 0,
                              flatbuffers::Offset<flatbuffers::Vector<int32_t>>
                                  embedding_dim_per_channel = 0) {
  ConcatEmbeddingsOptionsBuilder builder_(_fbb);
  builder_.add_embedding_dim_per_channel(embedding_dim_per_channel);
  builder_.add_num_columns_per_channel(num_columns_per_channel);
  builder_.add_num_channels(num_channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions>
CreateConcatEmbeddingsOptionsDirect(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t num_channels = 0,
    const std::vector<int32_t>* num_columns_per_channel = nullptr,
    const std::vector<int32_t>* embedding_dim_per_channel = nullptr) {
  auto num_columns_per_channel__ =
      num_columns_per_channel
          ? _fbb.CreateVector<int32_t>(*num_columns_per_channel)
          : 0;
  auto embedding_dim_per_channel__ =
      embedding_dim_per_channel
          ? _fbb.CreateVector<int32_t>(*embedding_dim_per_channel)
          : 0;
  return tflite::CreateConcatEmbeddingsOptions(_fbb, num_channels,
                                               num_columns_per_channel__,
                                               embedding_dim_per_channel__);
}

struct LSHProjectionOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return LSHProjectionOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  tflite::LSHProjectionType type() const {
    return static_cast<tflite::LSHProjectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) && verifier.EndTable();
  }
};

struct LSHProjectionOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(tflite::LSHProjectionType type) {
    fbb_.AddElement<int8_t>(LSHProjectionOptions::VT_TYPE,
                            static_cast<int8_t>(type), 0);
  }
  explicit LSHProjectionOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSHProjectionOptionsBuilder& operator=(const LSHProjectionOptionsBuilder&);
  flatbuffers::Offset<LSHProjectionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSHProjectionOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::LSHProjectionType type = tflite::LSHProjectionType_UNKNOWN) {
  LSHProjectionOptionsBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct SVDFOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SVDFOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RANK = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  int32_t rank() const { return GetField<int32_t>(VT_RANK, 0); }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct SVDFOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(SVDFOptions::VT_RANK, rank, 0);
  }
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(SVDFOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs),
                             0);
  }
  explicit SVDFOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVDFOptionsBuilder& operator=(const SVDFOptionsBuilder&);
  flatbuffers::Offset<SVDFOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SVDFOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t rank = 0,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  SVDFOptionsBuilder builder_(_fbb);
  builder_.add_rank(rank);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct RNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return RNNOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 6
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct RNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(RNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs),
                             0);
  }
  explicit RNNOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RNNOptionsBuilder& operator=(const RNNOptionsBuilder&);
  flatbuffers::Offset<RNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  RNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct SequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SequenceRNNOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  bool time_major() const { return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0; }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct SequenceRNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_TIME_MAJOR,
                             static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs),
                             0);
  }
  explicit SequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SequenceRNNOptionsBuilder& operator=(const SequenceRNNOptionsBuilder&);
  flatbuffers::Offset<SequenceRNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SequenceRNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder& _fbb, bool time_major = false,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  SequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

struct BidirectionalSequenceRNNOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return BidirectionalSequenceRNNOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_MERGE_OUTPUTS = 8,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 10
  };
  bool time_major() const { return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0; }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool merge_outputs() const {
    return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct BidirectionalSequenceRNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR,
                             static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(
        BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
        static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_merge_outputs(bool merge_outputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS,
                             static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(
        BidirectionalSequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
        static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BidirectionalSequenceRNNOptionsBuilder(
      flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BidirectionalSequenceRNNOptionsBuilder& operator=(
      const BidirectionalSequenceRNNOptionsBuilder&);
  flatbuffers::Offset<BidirectionalSequenceRNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BidirectionalSequenceRNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions>
CreateBidirectionalSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder& _fbb, bool time_major = false,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE,
    bool merge_outputs = false, bool asymmetric_quantize_inputs = false) {
  BidirectionalSequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

struct FullyConnectedOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return FullyConnectedOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_WEIGHTS_FORMAT = 6,
    VT_KEEP_NUM_DIMS = 8,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 10
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  tflite::FullyConnectedOptionsWeightsFormat weights_format() const {
    return static_cast<tflite::FullyConnectedOptionsWeightsFormat>(
        GetField<int8_t>(VT_WEIGHTS_FORMAT, 0));
  }
  bool keep_num_dims() const {
    return GetField<uint8_t>(VT_KEEP_NUM_DIMS, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int8_t>(verifier, VT_WEIGHTS_FORMAT) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_NUM_DIMS) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct FullyConnectedOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_weights_format(
      tflite::FullyConnectedOptionsWeightsFormat weights_format) {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_WEIGHTS_FORMAT,
                            static_cast<int8_t>(weights_format), 0);
  }
  void add_keep_num_dims(bool keep_num_dims) {
    fbb_.AddElement<uint8_t>(FullyConnectedOptions::VT_KEEP_NUM_DIMS,
                             static_cast<uint8_t>(keep_num_dims), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(
        FullyConnectedOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
        static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit FullyConnectedOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FullyConnectedOptionsBuilder& operator=(const FullyConnectedOptionsBuilder&);
  flatbuffers::Offset<FullyConnectedOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FullyConnectedOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE,
    tflite::FullyConnectedOptionsWeightsFormat weights_format =
        tflite::FullyConnectedOptionsWeightsFormat_DEFAULT,
    bool keep_num_dims = false, bool asymmetric_quantize_inputs = false) {
  FullyConnectedOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_keep_num_dims(keep_num_dims);
  builder_.add_weights_format(weights_format);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct SoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SoftmaxOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const { return GetField<float>(VT_BETA, 0.0f); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) && verifier.EndTable();
  }
};

struct SoftmaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SoftmaxOptions::VT_BETA, beta, 0.0f);
  }
  explicit SoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxOptionsBuilder& operator=(const SoftmaxOptionsBuilder&);
  flatbuffers::Offset<SoftmaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(
    flatbuffers::FlatBufferBuilder& _fbb, float beta = 0.0f) {
  SoftmaxOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

struct ConcatenationOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ConcatenationOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct ConcatenationOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ConcatenationOptions::VT_AXIS, axis, 0);
  }
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit ConcatenationOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatenationOptionsBuilder& operator=(const ConcatenationOptionsBuilder&);
  flatbuffers::Offset<ConcatenationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatenationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t axis = 0,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE) {
  ConcatenationOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct AddOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return AddOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_POT_SCALE_INT16 = 6
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool pot_scale_int16() const {
    return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16) &&
           verifier.EndTable();
  }
};

struct AddOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_pot_scale_int16(bool pot_scale_int16) {
    fbb_.AddElement<uint8_t>(AddOptions::VT_POT_SCALE_INT16,
                             static_cast<uint8_t>(pot_scale_int16), 1);
  }
  explicit AddOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddOptionsBuilder& operator=(const AddOptionsBuilder&);
  flatbuffers::Offset<AddOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddOptions> CreateAddOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE,
    bool pot_scale_int16 = true) {
  AddOptionsBuilder builder_(_fbb);
  builder_.add_pot_scale_int16(pot_scale_int16);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct MulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return MulOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct MulOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit MulOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulOptionsBuilder& operator=(const MulOptionsBuilder&);
  flatbuffers::Offset<MulOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulOptions> CreateMulOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE) {
  MulOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct L2NormOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return L2NormOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct L2NormOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit L2NormOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  L2NormOptionsBuilder& operator=(const L2NormOptionsBuilder&);
  flatbuffers::Offset<L2NormOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<L2NormOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE) {
  L2NormOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct LocalResponseNormalizationOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return LocalResponseNormalizationOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RADIUS = 4,
    VT_BIAS = 6,
    VT_ALPHA = 8,
    VT_BETA = 10
  };
  int32_t radius() const { return GetField<int32_t>(VT_RADIUS, 0); }
  float bias() const { return GetField<float>(VT_BIAS, 0.0f); }
  float alpha() const { return GetField<float>(VT_ALPHA, 0.0f); }
  float beta() const { return GetField<float>(VT_BETA, 0.0f); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RADIUS) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) && verifier.EndTable();
  }
};

struct LocalResponseNormalizationOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_radius(int32_t radius) {
    fbb_.AddElement<int32_t>(LocalResponseNormalizationOptions::VT_RADIUS,
                             radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BIAS, bias,
                           0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_ALPHA, alpha,
                           0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BETA, beta,
                           0.0f);
  }
  explicit LocalResponseNormalizationOptionsBuilder(
      flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LocalResponseNormalizationOptionsBuilder& operator=(
      const LocalResponseNormalizationOptionsBuilder&);
  flatbuffers::Offset<LocalResponseNormalizationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LocalResponseNormalizationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LocalResponseNormalizationOptions>
CreateLocalResponseNormalizationOptions(flatbuffers::FlatBufferBuilder& _fbb,
                                        int32_t radius = 0, float bias = 0.0f,
                                        float alpha = 0.0f, float beta = 0.0f) {
  LocalResponseNormalizationOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_radius(radius);
  return builder_.Finish();
}

struct LSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return LSTMOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_KERNEL_TYPE = 10,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 12
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const { return GetField<float>(VT_CELL_CLIP, 0.0f); }
  float proj_clip() const { return GetField<float>(VT_PROJ_CLIP, 0.0f); }
  tflite::LSTMKernelType kernel_type() const {
    return static_cast<tflite::LSTMKernelType>(
        GetField<int8_t>(VT_KERNEL_TYPE, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<int8_t>(verifier, VT_KERNEL_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct LSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(LSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(LSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_kernel_type(tflite::LSTMKernelType kernel_type) {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_KERNEL_TYPE,
                            static_cast<int8_t>(kernel_type), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(LSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs),
                             0);
  }
  explicit LSTMOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSTMOptionsBuilder& operator=(const LSTMOptionsBuilder&);
  flatbuffers::Offset<LSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f, float proj_clip = 0.0f,
    tflite::LSTMKernelType kernel_type = tflite::LSTMKernelType_FULL,
    bool asymmetric_quantize_inputs = false) {
  LSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_kernel_type(kernel_type);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct UnidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return UnidirectionalSequenceLSTMOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_TIME_MAJOR = 10,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 12
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const { return GetField<float>(VT_CELL_CLIP, 0.0f); }
  float proj_clip() const { return GetField<float>(VT_PROJ_CLIP, 0.0f); }
  bool time_major() const { return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0; }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct UnidirectionalSequenceLSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(
        UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
        static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP,
                           cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP,
                           proj_clip, 0.0f);
  }
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR,
                             static_cast<uint8_t>(time_major), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(
        UnidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
        static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit UnidirectionalSequenceLSTMOptionsBuilder(
      flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnidirectionalSequenceLSTMOptionsBuilder& operator=(
      const UnidirectionalSequenceLSTMOptionsBuilder&);
  flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>
CreateUnidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f, float proj_clip = 0.0f, bool time_major = false,
    bool asymmetric_quantize_inputs = false) {
  UnidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_time_major(time_major);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct BidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return BidirectionalSequenceLSTMOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_MERGE_OUTPUTS = 10,
    VT_TIME_MAJOR = 12,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 14
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const { return GetField<float>(VT_CELL_CLIP, 0.0f); }
  float proj_clip() const { return GetField<float>(VT_PROJ_CLIP, 0.0f); }
  bool merge_outputs() const {
    return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0;
  }
  bool time_major() const { return GetField<uint8_t>(VT_TIME_MAJOR, 1) != 0; }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct BidirectionalSequenceLSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(
        BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
        static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_CELL_CLIP,
                           cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP,
                           proj_clip, 0.0f);
  }
  void add_merge_outputs(bool merge_outputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS,
                             static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_TIME_MAJOR,
                             static_cast<uint8_t>(time_major), 1);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(
        BidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
        static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BidirectionalSequenceLSTMOptionsBuilder(
      flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BidirectionalSequenceLSTMOptionsBuilder& operator=(
      const BidirectionalSequenceLSTMOptionsBuilder&);
  flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions>
CreateBidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE,
    float cell_clip = 0.0f, float proj_clip = 0.0f, bool merge_outputs = false,
    bool time_major = true, bool asymmetric_quantize_inputs = false) {
  BidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_time_major(time_major);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct ResizeBilinearOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ResizeBilinearOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALIGN_CORNERS = 8,
    VT_HALF_PIXEL_CENTERS = 10
  };
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  bool half_pixel_centers() const {
    return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS) &&
           verifier.EndTable();
  }
};

struct ResizeBilinearOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_ALIGN_CORNERS,
                             static_cast<uint8_t>(align_corners), 0);
  }
  void add_half_pixel_centers(bool half_pixel_centers) {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_HALF_PIXEL_CENTERS,
                             static_cast<uint8_t>(half_pixel_centers), 0);
  }
  explicit ResizeBilinearOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeBilinearOptionsBuilder& operator=(const ResizeBilinearOptionsBuilder&);
  flatbuffers::Offset<ResizeBilinearOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeBilinearOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(
    flatbuffers::FlatBufferBuilder& _fbb, bool align_corners = false,
    bool half_pixel_centers = false) {
  ResizeBilinearOptionsBuilder builder_(_fbb);
  builder_.add_half_pixel_centers(half_pixel_centers);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

struct ResizeNearestNeighborOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ResizeNearestNeighborOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALIGN_CORNERS = 4,
    VT_HALF_PIXEL_CENTERS = 6
  };
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  bool half_pixel_centers() const {
    return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS) &&
           verifier.EndTable();
  }
};

struct ResizeNearestNeighborOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS,
                             static_cast<uint8_t>(align_corners), 0);
  }
  void add_half_pixel_centers(bool half_pixel_centers) {
    fbb_.AddElement<uint8_t>(
        ResizeNearestNeighborOptions::VT_HALF_PIXEL_CENTERS,
        static_cast<uint8_t>(half_pixel_centers), 0);
  }
  explicit ResizeNearestNeighborOptionsBuilder(
      flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeNearestNeighborOptionsBuilder& operator=(
      const ResizeNearestNeighborOptionsBuilder&);
  flatbuffers::Offset<ResizeNearestNeighborOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeNearestNeighborOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeNearestNeighborOptions>
CreateResizeNearestNeighborOptions(flatbuffers::FlatBufferBuilder& _fbb,
                                   bool align_corners = false,
                                   bool half_pixel_centers = false) {
  ResizeNearestNeighborOptionsBuilder builder_(_fbb);
  builder_.add_half_pixel_centers(half_pixel_centers);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

struct CallOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return CallOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBGRAPH = 4
  };
  uint32_t subgraph() const { return GetField<uint32_t>(VT_SUBGRAPH, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SUBGRAPH) && verifier.EndTable();
  }
};

struct CallOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_subgraph(uint32_t subgraph) {
    fbb_.AddElement<uint32_t>(CallOptions::VT_SUBGRAPH, subgraph, 0);
  }
  explicit CallOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallOptionsBuilder& operator=(const CallOptionsBuilder&);
  flatbuffers::Offset<CallOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallOptions> CreateCallOptions(
    flatbuffers::FlatBufferBuilder& _fbb, uint32_t subgraph = 0) {
  CallOptionsBuilder builder_(_fbb);
  builder_.add_subgraph(subgraph);
  return builder_.Finish();
}

struct PadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return PadOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct PadOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit PadOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadOptionsBuilder& operator=(const PadOptionsBuilder&);
  flatbuffers::Offset<PadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadOptions> CreatePadOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  PadOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PadV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return PadV2OptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct PadV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit PadV2OptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadV2OptionsBuilder& operator=(const PadV2OptionsBuilder&);
  flatbuffers::Offset<PadV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(
    flatbuffers::FlatBufferBuilder& _fbb) {
  PadV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReshapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ReshapeOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEW_SHAPE = 4
  };
  const flatbuffers::Vector<int32_t>* new_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_NEW_SHAPE);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NEW_SHAPE) &&
           verifier.VerifyVector(new_shape()) && verifier.EndTable();
  }
};

struct ReshapeOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_new_shape(
      flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape) {
    fbb_.AddOffset(ReshapeOptions::VT_NEW_SHAPE, new_shape);
  }
  explicit ReshapeOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReshapeOptionsBuilder& operator=(const ReshapeOptionsBuilder&);
  flatbuffers::Offset<ReshapeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReshapeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape = 0) {
  ReshapeOptionsBuilder builder_(_fbb);
  builder_.add_new_shape(new_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptionsDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<int32_t>* new_shape = nullptr) {
  auto new_shape__ = new_shape ? _fbb.CreateVector<int32_t>(*new_shape) : 0;
  return tflite::CreateReshapeOptions(_fbb, new_shape__);
}

struct SpaceToBatchNDOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SpaceToBatchNDOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SpaceToBatchNDOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit SpaceToBatchNDOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToBatchNDOptionsBuilder& operator=(const SpaceToBatchNDOptionsBuilder&);
  flatbuffers::Offset<SpaceToBatchNDOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatchNDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  SpaceToBatchNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchToSpaceNDOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return BatchToSpaceNDOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct BatchToSpaceNDOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchToSpaceNDOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchToSpaceNDOptionsBuilder& operator=(const BatchToSpaceNDOptionsBuilder&);
  flatbuffers::Offset<BatchToSpaceNDOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpaceNDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  BatchToSpaceNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SkipGramOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SkipGramOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NGRAM_SIZE = 4,
    VT_MAX_SKIP_SIZE = 6,
    VT_INCLUDE_ALL_NGRAMS = 8
  };
  int32_t ngram_size() const { return GetField<int32_t>(VT_NGRAM_SIZE, 0); }
  int32_t max_skip_size() const {
    return GetField<int32_t>(VT_MAX_SKIP_SIZE, 0);
  }
  bool include_all_ngrams() const {
    return GetField<uint8_t>(VT_INCLUDE_ALL_NGRAMS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NGRAM_SIZE) &&
           VerifyField<int32_t>(verifier, VT_MAX_SKIP_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_NGRAMS) &&
           verifier.EndTable();
  }
};

struct SkipGramOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_ngram_size(int32_t ngram_size) {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_NGRAM_SIZE, ngram_size, 0);
  }
  void add_max_skip_size(int32_t max_skip_size) {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_MAX_SKIP_SIZE, max_skip_size,
                             0);
  }
  void add_include_all_ngrams(bool include_all_ngrams) {
    fbb_.AddElement<uint8_t>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS,
                             static_cast<uint8_t>(include_all_ngrams), 0);
  }
  explicit SkipGramOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkipGramOptionsBuilder& operator=(const SkipGramOptionsBuilder&);
  flatbuffers::Offset<SkipGramOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkipGramOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t ngram_size = 0,
    int32_t max_skip_size = 0, bool include_all_ngrams = false) {
  SkipGramOptionsBuilder builder_(_fbb);
  builder_.add_max_skip_size(max_skip_size);
  builder_.add_ngram_size(ngram_size);
  builder_.add_include_all_ngrams(include_all_ngrams);
  return builder_.Finish();
}

struct SpaceToDepthOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SpaceToDepthOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4
  };
  int32_t block_size() const { return GetField<int32_t>(VT_BLOCK_SIZE, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_SIZE) && verifier.EndTable();
  }
};

struct SpaceToDepthOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size) {
    fbb_.AddElement<int32_t>(SpaceToDepthOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  explicit SpaceToDepthOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToDepthOptionsBuilder& operator=(const SpaceToDepthOptionsBuilder&);
  flatbuffers::Offset<SpaceToDepthOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToDepthOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t block_size = 0) {
  SpaceToDepthOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

struct DepthToSpaceOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return DepthToSpaceOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4
  };
  int32_t block_size() const { return GetField<int32_t>(VT_BLOCK_SIZE, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_SIZE) && verifier.EndTable();
  }
};

struct DepthToSpaceOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size) {
    fbb_.AddElement<int32_t>(DepthToSpaceOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  explicit DepthToSpaceOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthToSpaceOptionsBuilder& operator=(const DepthToSpaceOptionsBuilder&);
  flatbuffers::Offset<DepthToSpaceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthToSpaceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t block_size = 0) {
  DepthToSpaceOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

struct SubOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SubOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_POT_SCALE_INT16 = 6
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool pot_scale_int16() const {
    return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16) &&
           verifier.EndTable();
  }
};

struct SubOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_pot_scale_int16(bool pot_scale_int16) {
    fbb_.AddElement<uint8_t>(SubOptions::VT_POT_SCALE_INT16,
                             static_cast<uint8_t>(pot_scale_int16), 1);
  }
  explicit SubOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubOptionsBuilder& operator=(const SubOptionsBuilder&);
  flatbuffers::Offset<SubOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubOptions> CreateSubOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE,
    bool pot_scale_int16 = true) {
  SubOptionsBuilder builder_(_fbb);
  builder_.add_pot_scale_int16(pot_scale_int16);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct DivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return DivOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  tflite::ActivationFunctionType fused_activation_function() const {
    return static_cast<tflite::ActivationFunctionType>(
        GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct DivOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(
      tflite::ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION,
                            static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit DivOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DivOptionsBuilder& operator=(const DivOptionsBuilder&);
  flatbuffers::Offset<DivOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivOptions> CreateDivOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::ActivationFunctionType fused_activation_function =
        tflite::ActivationFunctionType_NONE) {
  DivOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct TopKV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return TopKV2OptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct TopKV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit TopKV2OptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopKV2OptionsBuilder& operator=(const TopKV2OptionsBuilder&);
  flatbuffers::Offset<TopKV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopKV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(
    flatbuffers::FlatBufferBuilder& _fbb) {
  TopKV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct EmbeddingLookupSparseOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return EmbeddingLookupSparseOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMBINER = 4
  };
  tflite::CombinerType combiner() const {
    return static_cast<tflite::CombinerType>(GetField<int8_t>(VT_COMBINER, 0));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_COMBINER) && verifier.EndTable();
  }
};

struct EmbeddingLookupSparseOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_combiner(tflite::CombinerType combiner) {
    fbb_.AddElement<int8_t>(EmbeddingLookupSparseOptions::VT_COMBINER,
                            static_cast<int8_t>(combiner), 0);
  }
  explicit EmbeddingLookupSparseOptionsBuilder(
      flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmbeddingLookupSparseOptionsBuilder& operator=(
      const EmbeddingLookupSparseOptionsBuilder&);
  flatbuffers::Offset<EmbeddingLookupSparseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookupSparseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookupSparseOptions>
CreateEmbeddingLookupSparseOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::CombinerType combiner = tflite::CombinerType_SUM) {
  EmbeddingLookupSparseOptionsBuilder builder_(_fbb);
  builder_.add_combiner(combiner);
  return builder_.Finish();
}

struct GatherOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return GatherOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_BATCH_DIMS = 6
  };
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  int32_t batch_dims() const { return GetField<int32_t>(VT_BATCH_DIMS, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_BATCH_DIMS) && verifier.EndTable();
  }
};

struct GatherOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(GatherOptions::VT_AXIS, axis, 0);
  }
  void add_batch_dims(int32_t batch_dims) {
    fbb_.AddElement<int32_t>(GatherOptions::VT_BATCH_DIMS, batch_dims, 0);
  }
  explicit GatherOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherOptionsBuilder& operator=(const GatherOptionsBuilder&);
  flatbuffers::Offset<GatherOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t axis = 0,
    int32_t batch_dims = 0) {
  GatherOptionsBuilder builder_(_fbb);
  builder_.add_batch_dims(batch_dims);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct TransposeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return TransposeOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct TransposeOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit TransposeOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeOptionsBuilder& operator=(const TransposeOptionsBuilder&);
  flatbuffers::Offset<TransposeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  TransposeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ExpOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ExpOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct ExpOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpOptionsBuilder& operator=(const ExpOptionsBuilder&);
  flatbuffers::Offset<ExpOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpOptions> CreateExpOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  ExpOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CosOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return CosOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct CosOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit CosOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CosOptionsBuilder& operator=(const CosOptionsBuilder&);
  flatbuffers::Offset<CosOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CosOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CosOptions> CreateCosOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  CosOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReducerOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ReducerOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEP_DIMS = 4
  };
  bool keep_dims() const { return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0; }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) && verifier.EndTable();
  }
};

struct ReducerOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(ReducerOptions::VT_KEEP_DIMS,
                             static_cast<uint8_t>(keep_dims), 0);
  }
  explicit ReducerOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReducerOptionsBuilder& operator=(const ReducerOptionsBuilder&);
  flatbuffers::Offset<ReducerOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReducerOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(
    flatbuffers::FlatBufferBuilder& _fbb, bool keep_dims = false) {
  ReducerOptionsBuilder builder_(_fbb);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

struct SqueezeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SqueezeOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SQUEEZE_DIMS = 4
  };
  const flatbuffers::Vector<int32_t>* squeeze_dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_SQUEEZE_DIMS);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SQUEEZE_DIMS) &&
           verifier.VerifyVector(squeeze_dims()) && verifier.EndTable();
  }
};

struct SqueezeOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_squeeze_dims(
      flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims) {
    fbb_.AddOffset(SqueezeOptions::VT_SQUEEZE_DIMS, squeeze_dims);
  }
  explicit SqueezeOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SqueezeOptionsBuilder& operator=(const SqueezeOptionsBuilder&);
  flatbuffers::Offset<SqueezeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SqueezeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims = 0) {
  SqueezeOptionsBuilder builder_(_fbb);
  builder_.add_squeeze_dims(squeeze_dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptionsDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<int32_t>* squeeze_dims = nullptr) {
  auto squeeze_dims__ =
      squeeze_dims ? _fbb.CreateVector<int32_t>(*squeeze_dims) : 0;
  return tflite::CreateSqueezeOptions(_fbb, squeeze_dims__);
}

struct SplitOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SplitOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const { return GetField<int32_t>(VT_NUM_SPLITS, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_SPLITS) && verifier.EndTable();
  }
};

struct SplitOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits) {
    fbb_.AddElement<int32_t>(SplitOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitOptionsBuilder& operator=(const SplitOptionsBuilder&);
  flatbuffers::Offset<SplitOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t num_splits = 0) {
  SplitOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

struct SplitVOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SplitVOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const { return GetField<int32_t>(VT_NUM_SPLITS, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_SPLITS) && verifier.EndTable();
  }
};

struct SplitVOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits) {
    fbb_.AddElement<int32_t>(SplitVOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitVOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitVOptionsBuilder& operator=(const SplitVOptionsBuilder&);
  flatbuffers::Offset<SplitVOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitVOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t num_splits = 0) {
  SplitVOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

struct StridedSliceOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return StridedSliceOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN_MASK = 4,
    VT_END_MASK = 6,
    VT_ELLIPSIS_MASK = 8,
    VT_NEW_AXIS_MASK = 10,
    VT_SHRINK_AXIS_MASK = 12
  };
  int32_t begin_mask() const { return GetField<int32_t>(VT_BEGIN_MASK, 0); }
  int32_t end_mask() const { return GetField<int32_t>(VT_END_MASK, 0); }
  int32_t ellipsis_mask() const {
    return GetField<int32_t>(VT_ELLIPSIS_MASK, 0);
  }
  int32_t new_axis_mask() const {
    return GetField<int32_t>(VT_NEW_AXIS_MASK, 0);
  }
  int32_t shrink_axis_mask() const {
    return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BEGIN_MASK) &&
           VerifyField<int32_t>(verifier, VT_END_MASK) &&
           VerifyField<int32_t>(verifier, VT_ELLIPSIS_MASK) &&
           VerifyField<int32_t>(verifier, VT_NEW_AXIS_MASK) &&
           VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK) &&
           verifier.EndTable();
  }
};

struct StridedSliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_mask(int32_t begin_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int32_t end_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_END_MASK, end_mask, 0);
  }
  void add_ellipsis_mask(int32_t ellipsis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_ELLIPSIS_MASK,
                             ellipsis_mask, 0);
  }
  void add_new_axis_mask(int32_t new_axis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_NEW_AXIS_MASK,
                             new_axis_mask, 0);
  }
  void add_shrink_axis_mask(int32_t shrink_axis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_SHRINK_AXIS_MASK,
                             shrink_axis_mask, 0);
  }
  explicit StridedSliceOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StridedSliceOptionsBuilder& operator=(const StridedSliceOptionsBuilder&);
  flatbuffers::Offset<StridedSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t begin_mask = 0,
    int32_t end_mask = 0, int32_t ellipsis_mask = 0, int32_t new_axis_mask = 0,
    int32_t shrink_axis_mask = 0) {
  StridedSliceOptionsBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_new_axis_mask(new_axis_mask);
  builder_.add_ellipsis_mask(ellipsis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  return builder_.Finish();
}

struct LogSoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return LogSoftmaxOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct LogSoftmaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogSoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogSoftmaxOptionsBuilder& operator=(const LogSoftmaxOptionsBuilder&);
  flatbuffers::Offset<LogSoftmaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogSoftmaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  LogSoftmaxOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CastOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return CastOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IN_DATA_TYPE = 4,
    VT_OUT_DATA_TYPE = 6
  };
  tflite::TensorType in_data_type() const {
    return static_cast<tflite::TensorType>(
        GetField<int8_t>(VT_IN_DATA_TYPE, 0));
  }
  tflite::TensorType out_data_type() const {
    return static_cast<tflite::TensorType>(
        GetField<int8_t>(VT_OUT_DATA_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_IN_DATA_TYPE) &&
           VerifyField<int8_t>(verifier, VT_OUT_DATA_TYPE) &&
           verifier.EndTable();
  }
};

struct CastOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_data_type(tflite::TensorType in_data_type) {
    fbb_.AddElement<int8_t>(CastOptions::VT_IN_DATA_TYPE,
                            static_cast<int8_t>(in_data_type), 0);
  }
  void add_out_data_type(tflite::TensorType out_data_type) {
    fbb_.AddElement<int8_t>(CastOptions::VT_OUT_DATA_TYPE,
                            static_cast<int8_t>(out_data_type), 0);
  }
  explicit CastOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CastOptionsBuilder& operator=(const CastOptionsBuilder&);
  flatbuffers::Offset<CastOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CastOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CastOptions> CreateCastOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::TensorType in_data_type = tflite::TensorType_FLOAT32,
    tflite::TensorType out_data_type = tflite::TensorType_FLOAT32) {
  CastOptionsBuilder builder_(_fbb);
  builder_.add_out_data_type(out_data_type);
  builder_.add_in_data_type(in_data_type);
  return builder_.Finish();
}

struct DequantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return DequantizeOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct DequantizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit DequantizeOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DequantizeOptionsBuilder& operator=(const DequantizeOptionsBuilder&);
  flatbuffers::Offset<DequantizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DequantizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  DequantizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MaximumMinimumOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return MaximumMinimumOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct MaximumMinimumOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaximumMinimumOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaximumMinimumOptionsBuilder& operator=(const MaximumMinimumOptionsBuilder&);
  flatbuffers::Offset<MaximumMinimumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaximumMinimumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  MaximumMinimumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return TileOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct TileOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit TileOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TileOptionsBuilder& operator=(const TileOptionsBuilder&);
  flatbuffers::Offset<TileOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TileOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TileOptions> CreateTileOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  TileOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ArgMaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ArgMaxOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_TYPE = 4
  };
  tflite::TensorType output_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) && verifier.EndTable();
  }
};

struct ArgMaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_type(tflite::TensorType output_type) {
    fbb_.AddElement<int8_t>(ArgMaxOptions::VT_OUTPUT_TYPE,
                            static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMaxOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMaxOptionsBuilder& operator=(const ArgMaxOptionsBuilder&);
  flatbuffers::Offset<ArgMaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::TensorType output_type = tflite::TensorType_FLOAT32) {
  ArgMaxOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

struct ArgMinOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ArgMinOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_TYPE = 4
  };
  tflite::TensorType output_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) && verifier.EndTable();
  }
};

struct ArgMinOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_type(tflite::TensorType output_type) {
    fbb_.AddElement<int8_t>(ArgMinOptions::VT_OUTPUT_TYPE,
                            static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMinOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMinOptionsBuilder& operator=(const ArgMinOptionsBuilder&);
  flatbuffers::Offset<ArgMinOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMinOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::TensorType output_type = tflite::TensorType_FLOAT32) {
  ArgMinOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

struct GreaterOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return GreaterOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct GreaterOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterOptionsBuilder& operator=(const GreaterOptionsBuilder&);
  flatbuffers::Offset<GreaterOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  GreaterOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GreaterEqualOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return GreaterEqualOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct GreaterEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterEqualOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterEqualOptionsBuilder& operator=(const GreaterEqualOptionsBuilder&);
  flatbuffers::Offset<GreaterEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  GreaterEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LessOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return LessOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct LessOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessOptionsBuilder& operator=(const LessOptionsBuilder&);
  flatbuffers::Offset<LessOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessOptions> CreateLessOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  LessOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LessEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return LessEqualOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct LessEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessEqualOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessEqualOptionsBuilder& operator=(const LessEqualOptionsBuilder&);
  flatbuffers::Offset<LessEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  LessEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NegOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return NegOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct NegOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NegOptionsBuilder& operator=(const NegOptionsBuilder&);
  flatbuffers::Offset<NegOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NegOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NegOptions> CreateNegOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  NegOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SelectOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SelectOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SelectOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectOptionsBuilder& operator=(const SelectOptionsBuilder&);
  flatbuffers::Offset<SelectOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  SelectOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SliceOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit SliceOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceOptionsBuilder& operator=(const SliceOptionsBuilder&);
  flatbuffers::Offset<SliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  SliceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TransposeConvOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return TransposeConvOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8
  };
  tflite::Padding padding() const {
    return static_cast<tflite::Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const { return GetField<int32_t>(VT_STRIDE_W, 0); }
  int32_t stride_h() const { return GetField<int32_t>(VT_STRIDE_H, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) && verifier.EndTable();
  }
};

struct TransposeConvOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(tflite::Padding padding) {
    fbb_.AddElement<int8_t>(TransposeConvOptions::VT_PADDING,
                            static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_H, stride_h, 0);
  }
  explicit TransposeConvOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeConvOptionsBuilder& operator=(const TransposeConvOptionsBuilder&);
  flatbuffers::Offset<TransposeConvOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeConvOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::Padding padding = tflite::Padding_SAME, int32_t stride_w = 0,
    int32_t stride_h = 0) {
  TransposeConvOptionsBuilder builder_(_fbb);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct ExpandDimsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ExpandDimsOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct ExpandDimsOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpandDimsOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpandDimsOptionsBuilder& operator=(const ExpandDimsOptionsBuilder&);
  flatbuffers::Offset<ExpandDimsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDimsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  ExpandDimsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SparseToDenseOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SparseToDenseOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALIDATE_INDICES = 4
  };
  bool validate_indices() const {
    return GetField<uint8_t>(VT_VALIDATE_INDICES, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALIDATE_INDICES) &&
           verifier.EndTable();
  }
};

struct SparseToDenseOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_validate_indices(bool validate_indices) {
    fbb_.AddElement<uint8_t>(SparseToDenseOptions::VT_VALIDATE_INDICES,
                             static_cast<uint8_t>(validate_indices), 0);
  }
  explicit SparseToDenseOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparseToDenseOptionsBuilder& operator=(const SparseToDenseOptionsBuilder&);
  flatbuffers::Offset<SparseToDenseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseToDenseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(
    flatbuffers::FlatBufferBuilder& _fbb, bool validate_indices = false) {
  SparseToDenseOptionsBuilder builder_(_fbb);
  builder_.add_validate_indices(validate_indices);
  return builder_.Finish();
}

struct EqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return EqualOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct EqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit EqualOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EqualOptionsBuilder& operator=(const EqualOptionsBuilder&);
  flatbuffers::Offset<EqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  EqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NotEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return NotEqualOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct NotEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit NotEqualOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotEqualOptionsBuilder& operator=(const NotEqualOptionsBuilder&);
  flatbuffers::Offset<NotEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  NotEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ShapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ShapeOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUT_TYPE = 4
  };
  tflite::TensorType out_type() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_OUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUT_TYPE) && verifier.EndTable();
  }
};

struct ShapeOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_out_type(tflite::TensorType out_type) {
    fbb_.AddElement<int8_t>(ShapeOptions::VT_OUT_TYPE,
                            static_cast<int8_t>(out_type), 0);
  }
  explicit ShapeOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShapeOptionsBuilder& operator=(const ShapeOptionsBuilder&);
  flatbuffers::Offset<ShapeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShapeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::TensorType out_type = tflite::TensorType_FLOAT32) {
  ShapeOptionsBuilder builder_(_fbb);
  builder_.add_out_type(out_type);
  return builder_.Finish();
}

struct RankOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return RankOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct RankOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit RankOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RankOptionsBuilder& operator=(const RankOptionsBuilder&);
  flatbuffers::Offset<RankOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RankOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RankOptions> CreateRankOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  RankOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PowOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return PowOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct PowOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit PowOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PowOptionsBuilder& operator=(const PowOptionsBuilder&);
  flatbuffers::Offset<PowOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowOptions> CreatePowOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  PowOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FakeQuantOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return FakeQuantOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_NUM_BITS = 8,
    VT_NARROW_RANGE = 10
  };
  float min() const { return GetField<float>(VT_MIN, 0.0f); }
  float max() const { return GetField<float>(VT_MAX, 0.0f); }
  int32_t num_bits() const { return GetField<int32_t>(VT_NUM_BITS, 0); }
  bool narrow_range() const {
    return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_MIN) &&
           VerifyField<float>(verifier, VT_MAX) &&
           VerifyField<int32_t>(verifier, VT_NUM_BITS) &&
           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) &&
           verifier.EndTable();
  }
};

struct FakeQuantOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(float min) {
    fbb_.AddElement<float>(FakeQuantOptions::VT_MIN, min, 0.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(FakeQuantOptions::VT_MAX, max, 0.0f);
  }
  void add_num_bits(int32_t num_bits) {
    fbb_.AddElement<int32_t>(FakeQuantOptions::VT_NUM_BITS, num_bits, 0);
  }
  void add_narrow_range(bool narrow_range) {
    fbb_.AddElement<uint8_t>(FakeQuantOptions::VT_NARROW_RANGE,
                             static_cast<uint8_t>(narrow_range), 0);
  }
  explicit FakeQuantOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FakeQuantOptionsBuilder& operator=(const FakeQuantOptionsBuilder&);
  flatbuffers::Offset<FakeQuantOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(
    flatbuffers::FlatBufferBuilder& _fbb, float min = 0.0f, float max = 0.0f,
    int32_t num_bits = 0, bool narrow_range = false) {
  FakeQuantOptionsBuilder builder_(_fbb);
  builder_.add_num_bits(num_bits);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_narrow_range(narrow_range);
  return builder_.Finish();
}

struct PackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return PackOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES_COUNT = 4,
    VT_AXIS = 6
  };
  int32_t values_count() const { return GetField<int32_t>(VT_VALUES_COUNT, 0); }
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUES_COUNT) &&
           VerifyField<int32_t>(verifier, VT_AXIS) && verifier.EndTable();
  }
};

struct PackOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_values_count(int32_t values_count) {
    fbb_.AddElement<int32_t>(PackOptions::VT_VALUES_COUNT, values_count, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(PackOptions::VT_AXIS, axis, 0);
  }
  explicit PackOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PackOptionsBuilder& operator=(const PackOptionsBuilder&);
  flatbuffers::Offset<PackOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PackOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PackOptions> CreatePackOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t values_count = 0,
    int32_t axis = 0) {
  PackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_values_count(values_count);
  return builder_.Finish();
}

struct LogicalOrOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return LogicalOrOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct LogicalOrOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalOrOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalOrOptionsBuilder& operator=(const LogicalOrOptionsBuilder&);
  flatbuffers::Offset<LogicalOrOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalOrOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  LogicalOrOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OneHotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return OneHotOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) && verifier.EndTable();
  }
};

struct OneHotOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(OneHotOptions::VT_AXIS, axis, 0);
  }
  explicit OneHotOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OneHotOptionsBuilder& operator=(const OneHotOptionsBuilder&);
  flatbuffers::Offset<OneHotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneHotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t axis = 0) {
  OneHotOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct AbsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return AbsOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct AbsOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AbsOptionsBuilder& operator=(const AbsOptionsBuilder&);
  flatbuffers::Offset<AbsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AbsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AbsOptions> CreateAbsOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  AbsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HardSwishOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return HardSwishOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct HardSwishOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit HardSwishOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HardSwishOptionsBuilder& operator=(const HardSwishOptionsBuilder&);
  flatbuffers::Offset<HardSwishOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardSwishOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  HardSwishOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalAndOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return LogicalAndOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct LogicalAndOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalAndOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalAndOptionsBuilder& operator=(const LogicalAndOptionsBuilder&);
  flatbuffers::Offset<LogicalAndOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalAndOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  LogicalAndOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalNotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return LogicalNotOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct LogicalNotOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalNotOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalNotOptionsBuilder& operator=(const LogicalNotOptionsBuilder&);
  flatbuffers::Offset<LogicalNotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalNotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  LogicalNotOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UnpackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return UnpackOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM = 4,
    VT_AXIS = 6
  };
  int32_t num() const { return GetField<int32_t>(VT_NUM, 0); }
  int32_t axis() const { return GetField<int32_t>(VT_AXIS, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM) &&
           VerifyField<int32_t>(verifier, VT_AXIS) && verifier.EndTable();
  }
};

struct UnpackOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_num(int32_t num) {
    fbb_.AddElement<int32_t>(UnpackOptions::VT_NUM, num, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(UnpackOptions::VT_AXIS, axis, 0);
  }
  explicit UnpackOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnpackOptionsBuilder& operator=(const UnpackOptionsBuilder&);
  flatbuffers::Offset<UnpackOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnpackOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t num = 0, int32_t axis = 0) {
  UnpackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_num(num);
  return builder_.Finish();
}

struct FloorDivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return FloorDivOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct FloorDivOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorDivOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorDivOptionsBuilder& operator=(const FloorDivOptionsBuilder&);
  flatbuffers::Offset<FloorDivOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorDivOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  FloorDivOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SquareOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SquareOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SquareOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquareOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquareOptionsBuilder& operator=(const SquareOptionsBuilder&);
  flatbuffers::Offset<SquareOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquareOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  SquareOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ZerosLikeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ZerosLikeOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct ZerosLikeOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit ZerosLikeOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ZerosLikeOptionsBuilder& operator=(const ZerosLikeOptionsBuilder&);
  flatbuffers::Offset<ZerosLikeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ZerosLikeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  ZerosLikeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FillOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return FillOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct FillOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit FillOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FillOptionsBuilder& operator=(const FillOptionsBuilder&);
  flatbuffers::Offset<FillOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FillOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FillOptions> CreateFillOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  FillOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FloorModOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return FloorModOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct FloorModOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorModOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorModOptionsBuilder& operator=(const FloorModOptionsBuilder&);
  flatbuffers::Offset<FloorModOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorModOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  FloorModOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RangeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return RangeOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct RangeOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit RangeOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RangeOptionsBuilder& operator=(const RangeOptionsBuilder&);
  flatbuffers::Offset<RangeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RangeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RangeOptions> CreateRangeOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  RangeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LeakyReluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return LeakyReluOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const { return GetField<float>(VT_ALPHA, 0.0f); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) && verifier.EndTable();
  }
};

struct LeakyReluOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LeakyReluOptions::VT_ALPHA, alpha, 0.0f);
  }
  explicit LeakyReluOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeakyReluOptionsBuilder& operator=(const LeakyReluOptionsBuilder&);
  flatbuffers::Offset<LeakyReluOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyReluOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(
    flatbuffers::FlatBufferBuilder& _fbb, float alpha = 0.0f) {
  LeakyReluOptionsBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

struct SquaredDifferenceOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SquaredDifferenceOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SquaredDifferenceOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquaredDifferenceOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquaredDifferenceOptionsBuilder& operator=(
      const SquaredDifferenceOptionsBuilder&);
  flatbuffers::Offset<SquaredDifferenceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquaredDifferenceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquaredDifferenceOptions>
CreateSquaredDifferenceOptions(flatbuffers::FlatBufferBuilder& _fbb) {
  SquaredDifferenceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MirrorPadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return MirrorPadOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4
  };
  tflite::MirrorPadMode mode() const {
    return static_cast<tflite::MirrorPadMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE) && verifier.EndTable();
  }
};

struct MirrorPadOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(tflite::MirrorPadMode mode) {
    fbb_.AddElement<int8_t>(MirrorPadOptions::VT_MODE,
                            static_cast<int8_t>(mode), 0);
  }
  explicit MirrorPadOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MirrorPadOptionsBuilder& operator=(const MirrorPadOptionsBuilder&);
  flatbuffers::Offset<MirrorPadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MirrorPadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::MirrorPadMode mode = tflite::MirrorPadMode_REFLECT) {
  MirrorPadOptionsBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct UniqueOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return UniqueOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDX_OUT_TYPE = 4
  };
  tflite::TensorType idx_out_type() const {
    return static_cast<tflite::TensorType>(
        GetField<int8_t>(VT_IDX_OUT_TYPE, 2));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_IDX_OUT_TYPE) &&
           verifier.EndTable();
  }
};

struct UniqueOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx_out_type(tflite::TensorType idx_out_type) {
    fbb_.AddElement<int8_t>(UniqueOptions::VT_IDX_OUT_TYPE,
                            static_cast<int8_t>(idx_out_type), 2);
  }
  explicit UniqueOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniqueOptionsBuilder& operator=(const UniqueOptionsBuilder&);
  flatbuffers::Offset<UniqueOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UniqueOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    tflite::TensorType idx_out_type = tflite::TensorType_INT32) {
  UniqueOptionsBuilder builder_(_fbb);
  builder_.add_idx_out_type(idx_out_type);
  return builder_.Finish();
}

struct ReverseV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ReverseV2OptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct ReverseV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReverseV2OptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseV2OptionsBuilder& operator=(const ReverseV2OptionsBuilder&);
  flatbuffers::Offset<ReverseV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(
    flatbuffers::FlatBufferBuilder& _fbb) {
  ReverseV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AddNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return AddNOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct AddNOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddNOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddNOptionsBuilder& operator=(const AddNOptionsBuilder&);
  flatbuffers::Offset<AddNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddNOptions> CreateAddNOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  AddNOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GatherNdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return GatherNdOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct GatherNdOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit GatherNdOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherNdOptionsBuilder& operator=(const GatherNdOptionsBuilder&);
  flatbuffers::Offset<GatherNdOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherNdOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  GatherNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct WhereOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return WhereOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct WhereOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit WhereOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WhereOptionsBuilder& operator=(const WhereOptionsBuilder&);
  flatbuffers::Offset<WhereOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WhereOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<WhereOptions> CreateWhereOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  WhereOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReverseSequenceOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ReverseSequenceOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQ_DIM = 4,
    VT_BATCH_DIM = 6
  };
  int32_t seq_dim() const { return GetField<int32_t>(VT_SEQ_DIM, 0); }
  int32_t batch_dim() const { return GetField<int32_t>(VT_BATCH_DIM, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEQ_DIM) &&
           VerifyField<int32_t>(verifier, VT_BATCH_DIM) && verifier.EndTable();
  }
};

struct ReverseSequenceOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_seq_dim(int32_t seq_dim) {
    fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_SEQ_DIM, seq_dim, 0);
  }
  void add_batch_dim(int32_t batch_dim) {
    fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_BATCH_DIM, batch_dim,
                             0);
  }
  explicit ReverseSequenceOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseSequenceOptionsBuilder& operator=(
      const ReverseSequenceOptionsBuilder&);
  flatbuffers::Offset<ReverseSequenceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseSequenceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t seq_dim = 0,
    int32_t batch_dim = 0) {
  ReverseSequenceOptionsBuilder builder_(_fbb);
  builder_.add_batch_dim(batch_dim);
  builder_.add_seq_dim(seq_dim);
  return builder_.Finish();
}

struct MatrixDiagOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return MatrixDiagOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct MatrixDiagOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit MatrixDiagOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatrixDiagOptionsBuilder& operator=(const MatrixDiagOptionsBuilder&);
  flatbuffers::Offset<MatrixDiagOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixDiagOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  MatrixDiagOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct QuantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return QuantizeOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct QuantizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit QuantizeOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizeOptionsBuilder& operator=(const QuantizeOptionsBuilder&);
  flatbuffers::Offset<QuantizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  QuantizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MatrixSetDiagOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return MatrixSetDiagOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct MatrixSetDiagOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit MatrixSetDiagOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatrixSetDiagOptionsBuilder& operator=(const MatrixSetDiagOptionsBuilder&);
  flatbuffers::Offset<MatrixSetDiagOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixSetDiagOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  MatrixSetDiagOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct IfOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return IfOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THEN_SUBGRAPH_INDEX = 4,
    VT_ELSE_SUBGRAPH_INDEX = 6
  };
  int32_t then_subgraph_index() const {
    return GetField<int32_t>(VT_THEN_SUBGRAPH_INDEX, 0);
  }
  int32_t else_subgraph_index() const {
    return GetField<int32_t>(VT_ELSE_SUBGRAPH_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_THEN_SUBGRAPH_INDEX) &&
           VerifyField<int32_t>(verifier, VT_ELSE_SUBGRAPH_INDEX) &&
           verifier.EndTable();
  }
};

struct IfOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_then_subgraph_index(int32_t then_subgraph_index) {
    fbb_.AddElement<int32_t>(IfOptions::VT_THEN_SUBGRAPH_INDEX,
                             then_subgraph_index, 0);
  }
  void add_else_subgraph_index(int32_t else_subgraph_index) {
    fbb_.AddElement<int32_t>(IfOptions::VT_ELSE_SUBGRAPH_INDEX,
                             else_subgraph_index, 0);
  }
  explicit IfOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IfOptionsBuilder& operator=(const IfOptionsBuilder&);
  flatbuffers::Offset<IfOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IfOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<IfOptions> CreateIfOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t then_subgraph_index = 0,
    int32_t else_subgraph_index = 0) {
  IfOptionsBuilder builder_(_fbb);
  builder_.add_else_subgraph_index(else_subgraph_index);
  builder_.add_then_subgraph_index(then_subgraph_index);
  return builder_.Finish();
}

struct CallOnceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return CallOnceOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INIT_SUBGRAPH_INDEX = 4
  };
  int32_t init_subgraph_index() const {
    return GetField<int32_t>(VT_INIT_SUBGRAPH_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INIT_SUBGRAPH_INDEX) &&
           verifier.EndTable();
  }
};

struct CallOnceOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_init_subgraph_index(int32_t init_subgraph_index) {
    fbb_.AddElement<int32_t>(CallOnceOptions::VT_INIT_SUBGRAPH_INDEX,
                             init_subgraph_index, 0);
  }
  explicit CallOnceOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallOnceOptionsBuilder& operator=(const CallOnceOptionsBuilder&);
  flatbuffers::Offset<CallOnceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallOnceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t init_subgraph_index = 0) {
  CallOnceOptionsBuilder builder_(_fbb);
  builder_.add_init_subgraph_index(init_subgraph_index);
  return builder_.Finish();
}

struct WhileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return WhileOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COND_SUBGRAPH_INDEX = 4,
    VT_BODY_SUBGRAPH_INDEX = 6
  };
  int32_t cond_subgraph_index() const {
    return GetField<int32_t>(VT_COND_SUBGRAPH_INDEX, 0);
  }
  int32_t body_subgraph_index() const {
    return GetField<int32_t>(VT_BODY_SUBGRAPH_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COND_SUBGRAPH_INDEX) &&
           VerifyField<int32_t>(verifier, VT_BODY_SUBGRAPH_INDEX) &&
           verifier.EndTable();
  }
};

struct WhileOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_cond_subgraph_index(int32_t cond_subgraph_index) {
    fbb_.AddElement<int32_t>(WhileOptions::VT_COND_SUBGRAPH_INDEX,
                             cond_subgraph_index, 0);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index) {
    fbb_.AddElement<int32_t>(WhileOptions::VT_BODY_SUBGRAPH_INDEX,
                             body_subgraph_index, 0);
  }
  explicit WhileOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WhileOptionsBuilder& operator=(const WhileOptionsBuilder&);
  flatbuffers::Offset<WhileOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WhileOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<WhileOptions> CreateWhileOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t cond_subgraph_index = 0,
    int32_t body_subgraph_index = 0) {
  WhileOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_cond_subgraph_index(cond_subgraph_index);
  return builder_.Finish();
}

struct NonMaxSuppressionV4Options FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return NonMaxSuppressionV4OptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct NonMaxSuppressionV4OptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV4OptionsBuilder(
      flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonMaxSuppressionV4OptionsBuilder& operator=(
      const NonMaxSuppressionV4OptionsBuilder&);
  flatbuffers::Offset<NonMaxSuppressionV4Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppressionV4Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppressionV4Options>
CreateNonMaxSuppressionV4Options(flatbuffers::FlatBufferBuilder& _fbb) {
  NonMaxSuppressionV4OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NonMaxSuppressionV5Options FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return NonMaxSuppressionV5OptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct NonMaxSuppressionV5OptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV5OptionsBuilder(
      flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonMaxSuppressionV5OptionsBuilder& operator=(
      const NonMaxSuppressionV5OptionsBuilder&);
  flatbuffers::Offset<NonMaxSuppressionV5Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppressionV5Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppressionV5Options>
CreateNonMaxSuppressionV5Options(flatbuffers::FlatBufferBuilder& _fbb) {
  NonMaxSuppressionV5OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ScatterNdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ScatterNdOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct ScatterNdOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterNdOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScatterNdOptionsBuilder& operator=(const ScatterNdOptionsBuilder&);
  flatbuffers::Offset<ScatterNdOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScatterNdOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  ScatterNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SelectV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SelectV2OptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SelectV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectV2OptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectV2OptionsBuilder& operator=(const SelectV2OptionsBuilder&);
  flatbuffers::Offset<SelectV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(
    flatbuffers::FlatBufferBuilder& _fbb) {
  SelectV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DensifyOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return DensifyOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct DensifyOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit DensifyOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DensifyOptionsBuilder& operator=(const DensifyOptionsBuilder&);
  flatbuffers::Offset<DensifyOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DensifyOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  DensifyOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SegmentSumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SegmentSumOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct SegmentSumOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit SegmentSumOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SegmentSumOptionsBuilder& operator=(const SegmentSumOptionsBuilder&);
  flatbuffers::Offset<SegmentSumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SegmentSumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  SegmentSumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchMatMulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return BatchMatMulOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADJ_X = 4,
    VT_ADJ_Y = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  bool adj_x() const { return GetField<uint8_t>(VT_ADJ_X, 0) != 0; }
  bool adj_y() const { return GetField<uint8_t>(VT_ADJ_Y, 0) != 0; }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ADJ_X) &&
           VerifyField<uint8_t>(verifier, VT_ADJ_Y) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct BatchMatMulOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_adj_x(bool adj_x) {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJ_X,
                             static_cast<uint8_t>(adj_x), 0);
  }
  void add_adj_y(bool adj_y) {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJ_Y,
                             static_cast<uint8_t>(adj_y), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                             static_cast<uint8_t>(asymmetric_quantize_inputs),
                             0);
  }
  explicit BatchMatMulOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchMatMulOptionsBuilder& operator=(const BatchMatMulOptionsBuilder&);
  flatbuffers::Offset<BatchMatMulOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchMatMulOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(
    flatbuffers::FlatBufferBuilder& _fbb, bool adj_x = false,
    bool adj_y = false, bool asymmetric_quantize_inputs = false) {
  BatchMatMulOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_adj_y(adj_y);
  builder_.add_adj_x(adj_x);
  return builder_.Finish();
}

struct CumsumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return CumsumOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXCLUSIVE = 4,
    VT_REVERSE = 6
  };
  bool exclusive() const { return GetField<uint8_t>(VT_EXCLUSIVE, 0) != 0; }
  bool reverse() const { return GetField<uint8_t>(VT_REVERSE, 0) != 0; }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXCLUSIVE) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE) && verifier.EndTable();
  }
};

struct CumsumOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_exclusive(bool exclusive) {
    fbb_.AddElement<uint8_t>(CumsumOptions::VT_EXCLUSIVE,
                             static_cast<uint8_t>(exclusive), 0);
  }
  void add_reverse(bool reverse) {
    fbb_.AddElement<uint8_t>(CumsumOptions::VT_REVERSE,
                             static_cast<uint8_t>(reverse), 0);
  }
  explicit CumsumOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CumsumOptionsBuilder& operator=(const CumsumOptionsBuilder&);
  flatbuffers::Offset<CumsumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CumsumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(
    flatbuffers::FlatBufferBuilder& _fbb, bool exclusive = false,
    bool reverse = false) {
  CumsumOptionsBuilder builder_(_fbb);
  builder_.add_reverse(reverse);
  builder_.add_exclusive(exclusive);
  return builder_.Finish();
}

struct BroadcastToOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return BroadcastToOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct BroadcastToOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit BroadcastToOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BroadcastToOptionsBuilder& operator=(const BroadcastToOptionsBuilder&);
  flatbuffers::Offset<BroadcastToOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BroadcastToOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  BroadcastToOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Rfft2dOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return Rfft2dOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct Rfft2dOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit Rfft2dOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Rfft2dOptionsBuilder& operator=(const Rfft2dOptionsBuilder&);
  flatbuffers::Offset<Rfft2dOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rfft2dOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  Rfft2dOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HashtableOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return HashtableOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TABLE_ID = 4,
    VT_KEY_DTYPE = 6,
    VT_VALUE_DTYPE = 8
  };
  int32_t table_id() const { return GetField<int32_t>(VT_TABLE_ID, 0); }
  tflite::TensorType key_dtype() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_KEY_DTYPE, 0));
  }
  tflite::TensorType value_dtype() const {
    return static_cast<tflite::TensorType>(GetField<int8_t>(VT_VALUE_DTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TABLE_ID) &&
           VerifyField<int8_t>(verifier, VT_KEY_DTYPE) &&
           VerifyField<int8_t>(verifier, VT_VALUE_DTYPE) && verifier.EndTable();
  }
};

struct HashtableOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_table_id(int32_t table_id) {
    fbb_.AddElement<int32_t>(HashtableOptions::VT_TABLE_ID, table_id, 0);
  }
  void add_key_dtype(tflite::TensorType key_dtype) {
    fbb_.AddElement<int8_t>(HashtableOptions::VT_KEY_DTYPE,
                            static_cast<int8_t>(key_dtype), 0);
  }
  void add_value_dtype(tflite::TensorType value_dtype) {
    fbb_.AddElement<int8_t>(HashtableOptions::VT_VALUE_DTYPE,
                            static_cast<int8_t>(value_dtype), 0);
  }
  explicit HashtableOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableOptionsBuilder& operator=(const HashtableOptionsBuilder&);
  flatbuffers::Offset<HashtableOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int32_t table_id = 0,
    tflite::TensorType key_dtype = tflite::TensorType_FLOAT32,
    tflite::TensorType value_dtype = tflite::TensorType_FLOAT32) {
  HashtableOptionsBuilder builder_(_fbb);
  builder_.add_table_id(table_id);
  builder_.add_value_dtype(value_dtype);
  builder_.add_key_dtype(key_dtype);
  return builder_.Finish();
}

struct HashtableFindOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return HashtableFindOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct HashtableFindOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableFindOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableFindOptionsBuilder& operator=(const HashtableFindOptionsBuilder&);
  flatbuffers::Offset<HashtableFindOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableFindOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  HashtableFindOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HashtableImportOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return HashtableImportOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct HashtableImportOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableImportOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableImportOptionsBuilder& operator=(
      const HashtableImportOptionsBuilder&);
  flatbuffers::Offset<HashtableImportOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableImportOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  HashtableImportOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HashtableSizeOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return HashtableSizeOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct HashtableSizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableSizeOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableSizeOptionsBuilder& operator=(const HashtableSizeOptionsBuilder&);
  flatbuffers::Offset<HashtableSizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableSizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  HashtableSizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct VarHandleOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return VarHandleOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTAINER = 4,
    VT_SHARED_NAME = 6
  };
  const flatbuffers::String* container() const {
    return GetPointer<const flatbuffers::String*>(VT_CONTAINER);
  }
  const flatbuffers::String* shared_name() const {
    return GetPointer<const flatbuffers::String*>(VT_SHARED_NAME);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_CONTAINER) &&
           verifier.VerifyString(container()) &&
           VerifyOffset(verifier, VT_SHARED_NAME) &&
           verifier.VerifyString(shared_name()) && verifier.EndTable();
  }
};

struct VarHandleOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_container(flatbuffers::Offset<flatbuffers::String> container) {
    fbb_.AddOffset(VarHandleOptions::VT_CONTAINER, container);
  }
  void add_shared_name(flatbuffers::Offset<flatbuffers::String> shared_name) {
    fbb_.AddOffset(VarHandleOptions::VT_SHARED_NAME, shared_name);
  }
  explicit VarHandleOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VarHandleOptionsBuilder& operator=(const VarHandleOptionsBuilder&);
  flatbuffers::Offset<VarHandleOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarHandleOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::String> container = 0,
    flatbuffers::Offset<flatbuffers::String> shared_name = 0) {
  VarHandleOptionsBuilder builder_(_fbb);
  builder_.add_shared_name(shared_name);
  builder_.add_container(container);
  return builder_.Finish();
}

inline flatbuffers::Offset<VarHandleOptions> CreateVarHandleOptionsDirect(
    flatbuffers::FlatBufferBuilder& _fbb, const char* container = nullptr,
    const char* shared_name = nullptr) {
  auto container__ = container ? _fbb.CreateString(container) : 0;
  auto shared_name__ = shared_name ? _fbb.CreateString(shared_name) : 0;
  return tflite::CreateVarHandleOptions(_fbb, container__, shared_name__);
}

struct ReadVariableOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ReadVariableOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct ReadVariableOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReadVariableOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadVariableOptionsBuilder& operator=(const ReadVariableOptionsBuilder&);
  flatbuffers::Offset<ReadVariableOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReadVariableOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReadVariableOptions> CreateReadVariableOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  ReadVariableOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AssignVariableOptions FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return AssignVariableOptionsTypeTable();
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct AssignVariableOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  explicit AssignVariableOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssignVariableOptionsBuilder& operator=(const AssignVariableOptionsBuilder&);
  flatbuffers::Offset<AssignVariableOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignVariableOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignVariableOptions> CreateAssignVariableOptions(
    flatbuffers::FlatBufferBuilder& _fbb) {
  AssignVariableOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RandomOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return RandomOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEED = 4,
    VT_SEED2 = 6
  };
  int64_t seed() const { return GetField<int64_t>(VT_SEED, 0); }
  int64_t seed2() const { return GetField<int64_t>(VT_SEED2, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SEED) &&
           VerifyField<int64_t>(verifier, VT_SEED2) && verifier.EndTable();
  }
};

struct RandomOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_seed(int64_t seed) {
    fbb_.AddElement<int64_t>(RandomOptions::VT_SEED, seed, 0);
  }
  void add_seed2(int64_t seed2) {
    fbb_.AddElement<int64_t>(RandomOptions::VT_SEED2, seed2, 0);
  }
  explicit RandomOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RandomOptionsBuilder& operator=(const RandomOptionsBuilder&);
  flatbuffers::Offset<RandomOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RandomOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RandomOptions> CreateRandomOptions(
    flatbuffers::FlatBufferBuilder& _fbb, int64_t seed = 0, int64_t seed2 = 0) {
  RandomOptionsBuilder builder_(_fbb);
  builder_.add_seed2(seed2);
  builder_.add_seed(seed);
  return builder_.Finish();
}

struct BucketizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return BucketizeOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOUNDARIES = 4
  };
  const flatbuffers::Vector<float>* boundaries() const {
    return GetPointer<const flatbuffers::Vector<float>*>(VT_BOUNDARIES);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BOUNDARIES) &&
           verifier.VerifyVector(boundaries()) && verifier.EndTable();
  }
};

struct BucketizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_boundaries(
      flatbuffers::Offset<flatbuffers::Vector<float>> boundaries) {
    fbb_.AddOffset(BucketizeOptions::VT_BOUNDARIES, boundaries);
  }
  explicit BucketizeOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BucketizeOptionsBuilder& operator=(const BucketizeOptionsBuilder&);
  flatbuffers::Offset<BucketizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BucketizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptions(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> boundaries = 0) {
  BucketizeOptionsBuilder builder_(_fbb);
  builder_.add_boundaries(boundaries);
  return builder_.Finish();
}

inline flatbuffers::Offset<BucketizeOptions> CreateBucketizeOptionsDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<float>* boundaries = nullptr) {
  auto boundaries__ = boundaries ? _fbb.CreateVector<float>(*boundaries) : 0;
  return tflite::CreateBucketizeOptions(_fbb, boundaries__);
}

struct GeluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return GeluOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPROXIMATE = 4
  };
  bool approximate() const { return GetField<uint8_t>(VT_APPROXIMATE, 0) != 0; }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_APPROXIMATE) &&
           verifier.EndTable();
  }
};

struct GeluOptionsBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_approximate(bool approximate) {
    fbb_.AddElement<uint8_t>(GeluOptions::VT_APPROXIMATE,
                             static_cast<uint8_t>(approximate), 0);
  }
  explicit GeluOptionsBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeluOptionsBuilder& operator=(const GeluOptionsBuilder&);
  flatbuffers::Offset<GeluOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeluOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeluOptions> CreateGeluOptions(
    flatbuffers::FlatBufferBuilder& _fbb, bool approximate = false) {
  GeluOptionsBuilder builder_(_fbb);
  builder_.add_approximate(approximate);
  return builder_.Finish();
}

struct OperatorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return OperatorCodeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEPRECATED_BUILTIN_CODE = 4,
    VT_CUSTOM_CODE = 6,
    VT_VERSION = 8,
    VT_BUILTIN_CODE = 10
  };
  int8_t deprecated_builtin_code() const {
    return GetField<int8_t>(VT_DEPRECATED_BUILTIN_CODE, 0);
  }
  const flatbuffers::String* custom_code() const {
    return GetPointer<const flatbuffers::String*>(VT_CUSTOM_CODE);
  }
  int32_t version() const { return GetField<int32_t>(VT_VERSION, 1); }
  tflite::BuiltinOperator builtin_code() const {
    return static_cast<tflite::BuiltinOperator>(
        GetField<int32_t>(VT_BUILTIN_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DEPRECATED_BUILTIN_CODE) &&
           VerifyOffset(verifier, VT_CUSTOM_CODE) &&
           verifier.VerifyString(custom_code()) &&
           VerifyField<int32_t>(verifier, VT_VERSION) &&
           VerifyField<int32_t>(verifier, VT_BUILTIN_CODE) &&
           verifier.EndTable();
  }
};

struct OperatorCodeBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_deprecated_builtin_code(int8_t deprecated_builtin_code) {
    fbb_.AddElement<int8_t>(OperatorCode::VT_DEPRECATED_BUILTIN_CODE,
                            deprecated_builtin_code, 0);
  }
  void add_custom_code(flatbuffers::Offset<flatbuffers::String> custom_code) {
    fbb_.AddOffset(OperatorCode::VT_CUSTOM_CODE, custom_code);
  }
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(OperatorCode::VT_VERSION, version, 1);
  }
  void add_builtin_code(tflite::BuiltinOperator builtin_code) {
    fbb_.AddElement<int32_t>(OperatorCode::VT_BUILTIN_CODE,
                             static_cast<int32_t>(builtin_code), 0);
  }
  explicit OperatorCodeBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OperatorCodeBuilder& operator=(const OperatorCodeBuilder&);
  flatbuffers::Offset<OperatorCode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorCode>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(
    flatbuffers::FlatBufferBuilder& _fbb, int8_t deprecated_builtin_code = 0,
    flatbuffers::Offset<flatbuffers::String> custom_code = 0,
    int32_t version = 1,
    tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD) {
  OperatorCodeBuilder builder_(_fbb);
  builder_.add_builtin_code(builtin_code);
  builder_.add_version(version);
  builder_.add_custom_code(custom_code);
  builder_.add_deprecated_builtin_code(deprecated_builtin_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<OperatorCode> CreateOperatorCodeDirect(
    flatbuffers::FlatBufferBuilder& _fbb, int8_t deprecated_builtin_code = 0,
    const char* custom_code = nullptr, int32_t version = 1,
    tflite::BuiltinOperator builtin_code = tflite::BuiltinOperator_ADD) {
  auto custom_code__ = custom_code ? _fbb.CreateString(custom_code) : 0;
  return tflite::CreateOperatorCode(_fbb, deprecated_builtin_code,
                                    custom_code__, version, builtin_code);
}

struct Operator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return OperatorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPCODE_INDEX = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_BUILTIN_OPTIONS_TYPE = 10,
    VT_BUILTIN_OPTIONS = 12,
    VT_CUSTOM_OPTIONS = 14,
    VT_CUSTOM_OPTIONS_FORMAT = 16,
    VT_MUTATING_VARIABLE_INPUTS = 18,
    VT_INTERMEDIATES = 20
  };
  uint32_t opcode_index() const {
    return GetField<uint32_t>(VT_OPCODE_INDEX, 0);
  }
  const flatbuffers::Vector<int32_t>* inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t>* outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_OUTPUTS);
  }
  tflite::BuiltinOptions builtin_options_type() const {
    return static_cast<tflite::BuiltinOptions>(
        GetField<uint8_t>(VT_BUILTIN_OPTIONS_TYPE, 0));
  }
  const void* builtin_options() const {
    return GetPointer<const void*>(VT_BUILTIN_OPTIONS);
  }
  template <typename T>
  const T* builtin_options_as() const;
  const tflite::Conv2DOptions* builtin_options_as_Conv2DOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_Conv2DOptions
               ? static_cast<const tflite::Conv2DOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::DepthwiseConv2DOptions*
  builtin_options_as_DepthwiseConv2DOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_DepthwiseConv2DOptions
               ? static_cast<const tflite::DepthwiseConv2DOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::ConcatEmbeddingsOptions*
  builtin_options_as_ConcatEmbeddingsOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_ConcatEmbeddingsOptions
               ? static_cast<const tflite::ConcatEmbeddingsOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::LSHProjectionOptions* builtin_options_as_LSHProjectionOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_LSHProjectionOptions
               ? static_cast<const tflite::LSHProjectionOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::Pool2DOptions* builtin_options_as_Pool2DOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_Pool2DOptions
               ? static_cast<const tflite::Pool2DOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::SVDFOptions* builtin_options_as_SVDFOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SVDFOptions
               ? static_cast<const tflite::SVDFOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::RNNOptions* builtin_options_as_RNNOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RNNOptions
               ? static_cast<const tflite::RNNOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::FullyConnectedOptions*
  builtin_options_as_FullyConnectedOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_FullyConnectedOptions
               ? static_cast<const tflite::FullyConnectedOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::SoftmaxOptions* builtin_options_as_SoftmaxOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SoftmaxOptions
               ? static_cast<const tflite::SoftmaxOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::ConcatenationOptions* builtin_options_as_ConcatenationOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_ConcatenationOptions
               ? static_cast<const tflite::ConcatenationOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::AddOptions* builtin_options_as_AddOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_AddOptions
               ? static_cast<const tflite::AddOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::L2NormOptions* builtin_options_as_L2NormOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_L2NormOptions
               ? static_cast<const tflite::L2NormOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::LocalResponseNormalizationOptions*
  builtin_options_as_LocalResponseNormalizationOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_LocalResponseNormalizationOptions
               ? static_cast<const tflite::LocalResponseNormalizationOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::LSTMOptions* builtin_options_as_LSTMOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LSTMOptions
               ? static_cast<const tflite::LSTMOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::ResizeBilinearOptions*
  builtin_options_as_ResizeBilinearOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_ResizeBilinearOptions
               ? static_cast<const tflite::ResizeBilinearOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::CallOptions* builtin_options_as_CallOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CallOptions
               ? static_cast<const tflite::CallOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::ReshapeOptions* builtin_options_as_ReshapeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReshapeOptions
               ? static_cast<const tflite::ReshapeOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::SkipGramOptions* builtin_options_as_SkipGramOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SkipGramOptions
               ? static_cast<const tflite::SkipGramOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::SpaceToDepthOptions* builtin_options_as_SpaceToDepthOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_SpaceToDepthOptions
               ? static_cast<const tflite::SpaceToDepthOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::EmbeddingLookupSparseOptions*
  builtin_options_as_EmbeddingLookupSparseOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_EmbeddingLookupSparseOptions
               ? static_cast<const tflite::EmbeddingLookupSparseOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::MulOptions* builtin_options_as_MulOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MulOptions
               ? static_cast<const tflite::MulOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::PadOptions* builtin_options_as_PadOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_PadOptions
               ? static_cast<const tflite::PadOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::GatherOptions* builtin_options_as_GatherOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GatherOptions
               ? static_cast<const tflite::GatherOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::BatchToSpaceNDOptions*
  builtin_options_as_BatchToSpaceNDOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_BatchToSpaceNDOptions
               ? static_cast<const tflite::BatchToSpaceNDOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::SpaceToBatchNDOptions*
  builtin_options_as_SpaceToBatchNDOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_SpaceToBatchNDOptions
               ? static_cast<const tflite::SpaceToBatchNDOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::TransposeOptions* builtin_options_as_TransposeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_TransposeOptions
               ? static_cast<const tflite::TransposeOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::ReducerOptions* builtin_options_as_ReducerOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReducerOptions
               ? static_cast<const tflite::ReducerOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::SubOptions* builtin_options_as_SubOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SubOptions
               ? static_cast<const tflite::SubOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::DivOptions* builtin_options_as_DivOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DivOptions
               ? static_cast<const tflite::DivOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::SqueezeOptions* builtin_options_as_SqueezeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SqueezeOptions
               ? static_cast<const tflite::SqueezeOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::SequenceRNNOptions* builtin_options_as_SequenceRNNOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_SequenceRNNOptions
               ? static_cast<const tflite::SequenceRNNOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::StridedSliceOptions* builtin_options_as_StridedSliceOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_StridedSliceOptions
               ? static_cast<const tflite::StridedSliceOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::ExpOptions* builtin_options_as_ExpOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ExpOptions
               ? static_cast<const tflite::ExpOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::TopKV2Options* builtin_options_as_TopKV2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_TopKV2Options
               ? static_cast<const tflite::TopKV2Options*>(builtin_options())
               : nullptr;
  }
  const tflite::SplitOptions* builtin_options_as_SplitOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SplitOptions
               ? static_cast<const tflite::SplitOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::LogSoftmaxOptions* builtin_options_as_LogSoftmaxOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_LogSoftmaxOptions
               ? static_cast<const tflite::LogSoftmaxOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::CastOptions* builtin_options_as_CastOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CastOptions
               ? static_cast<const tflite::CastOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::DequantizeOptions* builtin_options_as_DequantizeOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_DequantizeOptions
               ? static_cast<const tflite::DequantizeOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::MaximumMinimumOptions*
  builtin_options_as_MaximumMinimumOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_MaximumMinimumOptions
               ? static_cast<const tflite::MaximumMinimumOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::ArgMaxOptions* builtin_options_as_ArgMaxOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ArgMaxOptions
               ? static_cast<const tflite::ArgMaxOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::LessOptions* builtin_options_as_LessOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LessOptions
               ? static_cast<const tflite::LessOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::NegOptions* builtin_options_as_NegOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_NegOptions
               ? static_cast<const tflite::NegOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::PadV2Options* builtin_options_as_PadV2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_PadV2Options
               ? static_cast<const tflite::PadV2Options*>(builtin_options())
               : nullptr;
  }
  const tflite::GreaterOptions* builtin_options_as_GreaterOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GreaterOptions
               ? static_cast<const tflite::GreaterOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::GreaterEqualOptions* builtin_options_as_GreaterEqualOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_GreaterEqualOptions
               ? static_cast<const tflite::GreaterEqualOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::LessEqualOptions* builtin_options_as_LessEqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LessEqualOptions
               ? static_cast<const tflite::LessEqualOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::SelectOptions* builtin_options_as_SelectOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SelectOptions
               ? static_cast<const tflite::SelectOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::SliceOptions* builtin_options_as_SliceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SliceOptions
               ? static_cast<const tflite::SliceOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::TransposeConvOptions* builtin_options_as_TransposeConvOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_TransposeConvOptions
               ? static_cast<const tflite::TransposeConvOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::SparseToDenseOptions* builtin_options_as_SparseToDenseOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_SparseToDenseOptions
               ? static_cast<const tflite::SparseToDenseOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::TileOptions* builtin_options_as_TileOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_TileOptions
               ? static_cast<const tflite::TileOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::ExpandDimsOptions* builtin_options_as_ExpandDimsOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_ExpandDimsOptions
               ? static_cast<const tflite::ExpandDimsOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::EqualOptions* builtin_options_as_EqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_EqualOptions
               ? static_cast<const tflite::EqualOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::NotEqualOptions* builtin_options_as_NotEqualOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_NotEqualOptions
               ? static_cast<const tflite::NotEqualOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::ShapeOptions* builtin_options_as_ShapeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ShapeOptions
               ? static_cast<const tflite::ShapeOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::PowOptions* builtin_options_as_PowOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_PowOptions
               ? static_cast<const tflite::PowOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::ArgMinOptions* builtin_options_as_ArgMinOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ArgMinOptions
               ? static_cast<const tflite::ArgMinOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::FakeQuantOptions* builtin_options_as_FakeQuantOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FakeQuantOptions
               ? static_cast<const tflite::FakeQuantOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::PackOptions* builtin_options_as_PackOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_PackOptions
               ? static_cast<const tflite::PackOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::LogicalOrOptions* builtin_options_as_LogicalOrOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LogicalOrOptions
               ? static_cast<const tflite::LogicalOrOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::OneHotOptions* builtin_options_as_OneHotOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_OneHotOptions
               ? static_cast<const tflite::OneHotOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::LogicalAndOptions* builtin_options_as_LogicalAndOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_LogicalAndOptions
               ? static_cast<const tflite::LogicalAndOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::LogicalNotOptions* builtin_options_as_LogicalNotOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_LogicalNotOptions
               ? static_cast<const tflite::LogicalNotOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::UnpackOptions* builtin_options_as_UnpackOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_UnpackOptions
               ? static_cast<const tflite::UnpackOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::FloorDivOptions* builtin_options_as_FloorDivOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FloorDivOptions
               ? static_cast<const tflite::FloorDivOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::SquareOptions* builtin_options_as_SquareOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SquareOptions
               ? static_cast<const tflite::SquareOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::ZerosLikeOptions* builtin_options_as_ZerosLikeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ZerosLikeOptions
               ? static_cast<const tflite::ZerosLikeOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::FillOptions* builtin_options_as_FillOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FillOptions
               ? static_cast<const tflite::FillOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::BidirectionalSequenceLSTMOptions*
  builtin_options_as_BidirectionalSequenceLSTMOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_BidirectionalSequenceLSTMOptions
               ? static_cast<const tflite::BidirectionalSequenceLSTMOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::BidirectionalSequenceRNNOptions*
  builtin_options_as_BidirectionalSequenceRNNOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_BidirectionalSequenceRNNOptions
               ? static_cast<const tflite::BidirectionalSequenceRNNOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::UnidirectionalSequenceLSTMOptions*
  builtin_options_as_UnidirectionalSequenceLSTMOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_UnidirectionalSequenceLSTMOptions
               ? static_cast<const tflite::UnidirectionalSequenceLSTMOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::FloorModOptions* builtin_options_as_FloorModOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_FloorModOptions
               ? static_cast<const tflite::FloorModOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::RangeOptions* builtin_options_as_RangeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RangeOptions
               ? static_cast<const tflite::RangeOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::ResizeNearestNeighborOptions*
  builtin_options_as_ResizeNearestNeighborOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_ResizeNearestNeighborOptions
               ? static_cast<const tflite::ResizeNearestNeighborOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::LeakyReluOptions* builtin_options_as_LeakyReluOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_LeakyReluOptions
               ? static_cast<const tflite::LeakyReluOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::SquaredDifferenceOptions*
  builtin_options_as_SquaredDifferenceOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_SquaredDifferenceOptions
               ? static_cast<const tflite::SquaredDifferenceOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::MirrorPadOptions* builtin_options_as_MirrorPadOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_MirrorPadOptions
               ? static_cast<const tflite::MirrorPadOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::AbsOptions* builtin_options_as_AbsOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_AbsOptions
               ? static_cast<const tflite::AbsOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::SplitVOptions* builtin_options_as_SplitVOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_SplitVOptions
               ? static_cast<const tflite::SplitVOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::UniqueOptions* builtin_options_as_UniqueOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_UniqueOptions
               ? static_cast<const tflite::UniqueOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::ReverseV2Options* builtin_options_as_ReverseV2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_ReverseV2Options
               ? static_cast<const tflite::ReverseV2Options*>(builtin_options())
               : nullptr;
  }
  const tflite::AddNOptions* builtin_options_as_AddNOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_AddNOptions
               ? static_cast<const tflite::AddNOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::GatherNdOptions* builtin_options_as_GatherNdOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GatherNdOptions
               ? static_cast<const tflite::GatherNdOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::CosOptions* builtin_options_as_CosOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CosOptions
               ? static_cast<const tflite::CosOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::WhereOptions* builtin_options_as_WhereOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_WhereOptions
               ? static_cast<const tflite::WhereOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::RankOptions* builtin_options_as_RankOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RankOptions
               ? static_cast<const tflite::RankOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::ReverseSequenceOptions*
  builtin_options_as_ReverseSequenceOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_ReverseSequenceOptions
               ? static_cast<const tflite::ReverseSequenceOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::MatrixDiagOptions* builtin_options_as_MatrixDiagOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_MatrixDiagOptions
               ? static_cast<const tflite::MatrixDiagOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::QuantizeOptions* builtin_options_as_QuantizeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_QuantizeOptions
               ? static_cast<const tflite::QuantizeOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::MatrixSetDiagOptions* builtin_options_as_MatrixSetDiagOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_MatrixSetDiagOptions
               ? static_cast<const tflite::MatrixSetDiagOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::HardSwishOptions* builtin_options_as_HardSwishOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_HardSwishOptions
               ? static_cast<const tflite::HardSwishOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::IfOptions* builtin_options_as_IfOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_IfOptions
               ? static_cast<const tflite::IfOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::WhileOptions* builtin_options_as_WhileOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_WhileOptions
               ? static_cast<const tflite::WhileOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::DepthToSpaceOptions* builtin_options_as_DepthToSpaceOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_DepthToSpaceOptions
               ? static_cast<const tflite::DepthToSpaceOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::NonMaxSuppressionV4Options*
  builtin_options_as_NonMaxSuppressionV4Options() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_NonMaxSuppressionV4Options
               ? static_cast<const tflite::NonMaxSuppressionV4Options*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::NonMaxSuppressionV5Options*
  builtin_options_as_NonMaxSuppressionV5Options() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_NonMaxSuppressionV5Options
               ? static_cast<const tflite::NonMaxSuppressionV5Options*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::ScatterNdOptions* builtin_options_as_ScatterNdOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_ScatterNdOptions
               ? static_cast<const tflite::ScatterNdOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::SelectV2Options* builtin_options_as_SelectV2Options() const {
    return builtin_options_type() == tflite::BuiltinOptions_SelectV2Options
               ? static_cast<const tflite::SelectV2Options*>(builtin_options())
               : nullptr;
  }
  const tflite::DensifyOptions* builtin_options_as_DensifyOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_DensifyOptions
               ? static_cast<const tflite::DensifyOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::SegmentSumOptions* builtin_options_as_SegmentSumOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_SegmentSumOptions
               ? static_cast<const tflite::SegmentSumOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::BatchMatMulOptions* builtin_options_as_BatchMatMulOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_BatchMatMulOptions
               ? static_cast<const tflite::BatchMatMulOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::CumsumOptions* builtin_options_as_CumsumOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CumsumOptions
               ? static_cast<const tflite::CumsumOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::CallOnceOptions* builtin_options_as_CallOnceOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_CallOnceOptions
               ? static_cast<const tflite::CallOnceOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::BroadcastToOptions* builtin_options_as_BroadcastToOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_BroadcastToOptions
               ? static_cast<const tflite::BroadcastToOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::Rfft2dOptions* builtin_options_as_Rfft2dOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_Rfft2dOptions
               ? static_cast<const tflite::Rfft2dOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::Conv3DOptions* builtin_options_as_Conv3DOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_Conv3DOptions
               ? static_cast<const tflite::Conv3DOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::HashtableOptions* builtin_options_as_HashtableOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_HashtableOptions
               ? static_cast<const tflite::HashtableOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::HashtableFindOptions* builtin_options_as_HashtableFindOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_HashtableFindOptions
               ? static_cast<const tflite::HashtableFindOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::HashtableImportOptions*
  builtin_options_as_HashtableImportOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_HashtableImportOptions
               ? static_cast<const tflite::HashtableImportOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::HashtableSizeOptions* builtin_options_as_HashtableSizeOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_HashtableSizeOptions
               ? static_cast<const tflite::HashtableSizeOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::VarHandleOptions* builtin_options_as_VarHandleOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_VarHandleOptions
               ? static_cast<const tflite::VarHandleOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::ReadVariableOptions* builtin_options_as_ReadVariableOptions()
      const {
    return builtin_options_type() == tflite::BuiltinOptions_ReadVariableOptions
               ? static_cast<const tflite::ReadVariableOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::AssignVariableOptions*
  builtin_options_as_AssignVariableOptions() const {
    return builtin_options_type() ==
                   tflite::BuiltinOptions_AssignVariableOptions
               ? static_cast<const tflite::AssignVariableOptions*>(
                     builtin_options())
               : nullptr;
  }
  const tflite::RandomOptions* builtin_options_as_RandomOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_RandomOptions
               ? static_cast<const tflite::RandomOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::BucketizeOptions* builtin_options_as_BucketizeOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_BucketizeOptions
               ? static_cast<const tflite::BucketizeOptions*>(builtin_options())
               : nullptr;
  }
  const tflite::GeluOptions* builtin_options_as_GeluOptions() const {
    return builtin_options_type() == tflite::BuiltinOptions_GeluOptions
               ? static_cast<const tflite::GeluOptions*>(builtin_options())
               : nullptr;
  }
  const flatbuffers::Vector<uint8_t>* custom_options() const {
    return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_CUSTOM_OPTIONS);
  }
  tflite::CustomOptionsFormat custom_options_format() const {
    return static_cast<tflite::CustomOptionsFormat>(
        GetField<int8_t>(VT_CUSTOM_OPTIONS_FORMAT, 0));
  }
  const flatbuffers::Vector<uint8_t>* mutating_variable_inputs() const {
    return GetPointer<const flatbuffers::Vector<uint8_t>*>(
        VT_MUTATING_VARIABLE_INPUTS);
  }
  const flatbuffers::Vector<int32_t>* intermediates() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_INTERMEDIATES);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OPCODE_INDEX) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyField<uint8_t>(verifier, VT_BUILTIN_OPTIONS_TYPE) &&
           VerifyOffset(verifier, VT_BUILTIN_OPTIONS) &&
           VerifyBuiltinOptions(verifier, builtin_options(),
                                builtin_options_type()) &&
           VerifyOffset(verifier, VT_CUSTOM_OPTIONS) &&
           verifier.VerifyVector(custom_options()) &&
           VerifyField<int8_t>(verifier, VT_CUSTOM_OPTIONS_FORMAT) &&
           VerifyOffset(verifier, VT_MUTATING_VARIABLE_INPUTS) &&
           verifier.VerifyVector(mutating_variable_inputs()) &&
           VerifyOffset(verifier, VT_INTERMEDIATES) &&
           verifier.VerifyVector(intermediates()) && verifier.EndTable();
  }
};

template <>
inline const tflite::Conv2DOptions*
Operator::builtin_options_as<tflite::Conv2DOptions>() const {
  return builtin_options_as_Conv2DOptions();
}

template <>
inline const tflite::DepthwiseConv2DOptions*
Operator::builtin_options_as<tflite::DepthwiseConv2DOptions>() const {
  return builtin_options_as_DepthwiseConv2DOptions();
}

template <>
inline const tflite::ConcatEmbeddingsOptions*
Operator::builtin_options_as<tflite::ConcatEmbeddingsOptions>() const {
  return builtin_options_as_ConcatEmbeddingsOptions();
}

template <>
inline const tflite::LSHProjectionOptions*
Operator::builtin_options_as<tflite::LSHProjectionOptions>() const {
  return builtin_options_as_LSHProjectionOptions();
}

template <>
inline const tflite::Pool2DOptions*
Operator::builtin_options_as<tflite::Pool2DOptions>() const {
  return builtin_options_as_Pool2DOptions();
}

template <>
inline const tflite::SVDFOptions*
Operator::builtin_options_as<tflite::SVDFOptions>() const {
  return builtin_options_as_SVDFOptions();
}

template <>
inline const tflite::RNNOptions*
Operator::builtin_options_as<tflite::RNNOptions>() const {
  return builtin_options_as_RNNOptions();
}

template <>
inline const tflite::FullyConnectedOptions*
Operator::builtin_options_as<tflite::FullyConnectedOptions>() const {
  return builtin_options_as_FullyConnectedOptions();
}

template <>
inline const tflite::SoftmaxOptions*
Operator::builtin_options_as<tflite::SoftmaxOptions>() const {
  return builtin_options_as_SoftmaxOptions();
}

template <>
inline const tflite::ConcatenationOptions*
Operator::builtin_options_as<tflite::ConcatenationOptions>() const {
  return builtin_options_as_ConcatenationOptions();
}

template <>
inline const tflite::AddOptions*
Operator::builtin_options_as<tflite::AddOptions>() const {
  return builtin_options_as_AddOptions();
}

template <>
inline const tflite::L2NormOptions*
Operator::builtin_options_as<tflite::L2NormOptions>() const {
  return builtin_options_as_L2NormOptions();
}

template <>
inline const tflite::LocalResponseNormalizationOptions*
Operator::builtin_options_as<tflite::LocalResponseNormalizationOptions>()
    const {
  return builtin_options_as_LocalResponseNormalizationOptions();
}

template <>
inline const tflite::LSTMOptions*
Operator::builtin_options_as<tflite::LSTMOptions>() const {
  return builtin_options_as_LSTMOptions();
}

template <>
inline const tflite::ResizeBilinearOptions*
Operator::builtin_options_as<tflite::ResizeBilinearOptions>() const {
  return builtin_options_as_ResizeBilinearOptions();
}

template <>
inline const tflite::CallOptions*
Operator::builtin_options_as<tflite::CallOptions>() const {
  return builtin_options_as_CallOptions();
}

template <>
inline const tflite::ReshapeOptions*
Operator::builtin_options_as<tflite::ReshapeOptions>() const {
  return builtin_options_as_ReshapeOptions();
}

template <>
inline const tflite::SkipGramOptions*
Operator::builtin_options_as<tflite::SkipGramOptions>() const {
  return builtin_options_as_SkipGramOptions();
}

template <>
inline const tflite::SpaceToDepthOptions*
Operator::builtin_options_as<tflite::SpaceToDepthOptions>() const {
  return builtin_options_as_SpaceToDepthOptions();
}

template <>
inline const tflite::EmbeddingLookupSparseOptions*
Operator::builtin_options_as<tflite::EmbeddingLookupSparseOptions>() const {
  return builtin_options_as_EmbeddingLookupSparseOptions();
}

template <>
inline const tflite::MulOptions*
Operator::builtin_options_as<tflite::MulOptions>() const {
  return builtin_options_as_MulOptions();
}

template <>
inline const tflite::PadOptions*
Operator::builtin_options_as<tflite::PadOptions>() const {
  return builtin_options_as_PadOptions();
}

template <>
inline const tflite::GatherOptions*
Operator::builtin_options_as<tflite::GatherOptions>() const {
  return builtin_options_as_GatherOptions();
}

template <>
inline const tflite::BatchToSpaceNDOptions*
Operator::builtin_options_as<tflite::BatchToSpaceNDOptions>() const {
  return builtin_options_as_BatchToSpaceNDOptions();
}

template <>
inline const tflite::SpaceToBatchNDOptions*
Operator::builtin_options_as<tflite::SpaceToBatchNDOptions>() const {
  return builtin_options_as_SpaceToBatchNDOptions();
}

template <>
inline const tflite::TransposeOptions*
Operator::builtin_options_as<tflite::TransposeOptions>() const {
  return builtin_options_as_TransposeOptions();
}

template <>
inline const tflite::ReducerOptions*
Operator::builtin_options_as<tflite::ReducerOptions>() const {
  return builtin_options_as_ReducerOptions();
}

template <>
inline const tflite::SubOptions*
Operator::builtin_options_as<tflite::SubOptions>() const {
  return builtin_options_as_SubOptions();
}

template <>
inline const tflite::DivOptions*
Operator::builtin_options_as<tflite::DivOptions>() const {
  return builtin_options_as_DivOptions();
}

template <>
inline const tflite::SqueezeOptions*
Operator::builtin_options_as<tflite::SqueezeOptions>() const {
  return builtin_options_as_SqueezeOptions();
}

template <>
inline const tflite::SequenceRNNOptions*
Operator::builtin_options_as<tflite::SequenceRNNOptions>() const {
  return builtin_options_as_SequenceRNNOptions();
}

template <>
inline const tflite::StridedSliceOptions*
Operator::builtin_options_as<tflite::StridedSliceOptions>() const {
  return builtin_options_as_StridedSliceOptions();
}

template <>
inline const tflite::ExpOptions*
Operator::builtin_options_as<tflite::ExpOptions>() const {
  return builtin_options_as_ExpOptions();
}

template <>
inline const tflite::TopKV2Options*
Operator::builtin_options_as<tflite::TopKV2Options>() const {
  return builtin_options_as_TopKV2Options();
}

template <>
inline const tflite::SplitOptions*
Operator::builtin_options_as<tflite::SplitOptions>() const {
  return builtin_options_as_SplitOptions();
}

template <>
inline const tflite::LogSoftmaxOptions*
Operator::builtin_options_as<tflite::LogSoftmaxOptions>() const {
  return builtin_options_as_LogSoftmaxOptions();
}

template <>
inline const tflite::CastOptions*
Operator::builtin_options_as<tflite::CastOptions>() const {
  return builtin_options_as_CastOptions();
}

template <>
inline const tflite::DequantizeOptions*
Operator::builtin_options_as<tflite::DequantizeOptions>() const {
  return builtin_options_as_DequantizeOptions();
}

template <>
inline const tflite::MaximumMinimumOptions*
Operator::builtin_options_as<tflite::MaximumMinimumOptions>() const {
  return builtin_options_as_MaximumMinimumOptions();
}

template <>
inline const tflite::ArgMaxOptions*
Operator::builtin_options_as<tflite::ArgMaxOptions>() const {
  return builtin_options_as_ArgMaxOptions();
}

template <>
inline const tflite::LessOptions*
Operator::builtin_options_as<tflite::LessOptions>() const {
  return builtin_options_as_LessOptions();
}

template <>
inline const tflite::NegOptions*
Operator::builtin_options_as<tflite::NegOptions>() const {
  return builtin_options_as_NegOptions();
}

template <>
inline const tflite::PadV2Options*
Operator::builtin_options_as<tflite::PadV2Options>() const {
  return builtin_options_as_PadV2Options();
}

template <>
inline const tflite::GreaterOptions*
Operator::builtin_options_as<tflite::GreaterOptions>() const {
  return builtin_options_as_GreaterOptions();
}

template <>
inline const tflite::GreaterEqualOptions*
Operator::builtin_options_as<tflite::GreaterEqualOptions>() const {
  return builtin_options_as_GreaterEqualOptions();
}

template <>
inline const tflite::LessEqualOptions*
Operator::builtin_options_as<tflite::LessEqualOptions>() const {
  return builtin_options_as_LessEqualOptions();
}

template <>
inline const tflite::SelectOptions*
Operator::builtin_options_as<tflite::SelectOptions>() const {
  return builtin_options_as_SelectOptions();
}

template <>
inline const tflite::SliceOptions*
Operator::builtin_options_as<tflite::SliceOptions>() const {
  return builtin_options_as_SliceOptions();
}

template <>
inline const tflite::TransposeConvOptions*
Operator::builtin_options_as<tflite::TransposeConvOptions>() const {
  return builtin_options_as_TransposeConvOptions();
}

template <>
inline const tflite::SparseToDenseOptions*
Operator::builtin_options_as<tflite::SparseToDenseOptions>() const {
  return builtin_options_as_SparseToDenseOptions();
}

template <>
inline const tflite::TileOptions*
Operator::builtin_options_as<tflite::TileOptions>() const {
  return builtin_options_as_TileOptions();
}

template <>
inline const tflite::ExpandDimsOptions*
Operator::builtin_options_as<tflite::ExpandDimsOptions>() const {
  return builtin_options_as_ExpandDimsOptions();
}

template <>
inline const tflite::EqualOptions*
Operator::builtin_options_as<tflite::EqualOptions>() const {
  return builtin_options_as_EqualOptions();
}

template <>
inline const tflite::NotEqualOptions*
Operator::builtin_options_as<tflite::NotEqualOptions>() const {
  return builtin_options_as_NotEqualOptions();
}

template <>
inline const tflite::ShapeOptions*
Operator::builtin_options_as<tflite::ShapeOptions>() const {
  return builtin_options_as_ShapeOptions();
}

template <>
inline const tflite::PowOptions*
Operator::builtin_options_as<tflite::PowOptions>() const {
  return builtin_options_as_PowOptions();
}

template <>
inline const tflite::ArgMinOptions*
Operator::builtin_options_as<tflite::ArgMinOptions>() const {
  return builtin_options_as_ArgMinOptions();
}

template <>
inline const tflite::FakeQuantOptions*
Operator::builtin_options_as<tflite::FakeQuantOptions>() const {
  return builtin_options_as_FakeQuantOptions();
}

template <>
inline const tflite::PackOptions*
Operator::builtin_options_as<tflite::PackOptions>() const {
  return builtin_options_as_PackOptions();
}

template <>
inline const tflite::LogicalOrOptions*
Operator::builtin_options_as<tflite::LogicalOrOptions>() const {
  return builtin_options_as_LogicalOrOptions();
}

template <>
inline const tflite::OneHotOptions*
Operator::builtin_options_as<tflite::OneHotOptions>() const {
  return builtin_options_as_OneHotOptions();
}

template <>
inline const tflite::LogicalAndOptions*
Operator::builtin_options_as<tflite::LogicalAndOptions>() const {
  return builtin_options_as_LogicalAndOptions();
}

template <>
inline const tflite::LogicalNotOptions*
Operator::builtin_options_as<tflite::LogicalNotOptions>() const {
  return builtin_options_as_LogicalNotOptions();
}

template <>
inline const tflite::UnpackOptions*
Operator::builtin_options_as<tflite::UnpackOptions>() const {
  return builtin_options_as_UnpackOptions();
}

template <>
inline const tflite::FloorDivOptions*
Operator::builtin_options_as<tflite::FloorDivOptions>() const {
  return builtin_options_as_FloorDivOptions();
}

template <>
inline const tflite::SquareOptions*
Operator::builtin_options_as<tflite::SquareOptions>() const {
  return builtin_options_as_SquareOptions();
}

template <>
inline const tflite::ZerosLikeOptions*
Operator::builtin_options_as<tflite::ZerosLikeOptions>() const {
  return builtin_options_as_ZerosLikeOptions();
}

template <>
inline const tflite::FillOptions*
Operator::builtin_options_as<tflite::FillOptions>() const {
  return builtin_options_as_FillOptions();
}

template <>
inline const tflite::BidirectionalSequenceLSTMOptions*
Operator::builtin_options_as<tflite::BidirectionalSequenceLSTMOptions>() const {
  return builtin_options_as_BidirectionalSequenceLSTMOptions();
}

template <>
inline const tflite::BidirectionalSequenceRNNOptions*
Operator::builtin_options_as<tflite::BidirectionalSequenceRNNOptions>() const {
  return builtin_options_as_BidirectionalSequenceRNNOptions();
}

template <>
inline const tflite::UnidirectionalSequenceLSTMOptions*
Operator::builtin_options_as<tflite::UnidirectionalSequenceLSTMOptions>()
    const {
  return builtin_options_as_UnidirectionalSequenceLSTMOptions();
}

template <>
inline const tflite::FloorModOptions*
Operator::builtin_options_as<tflite::FloorModOptions>() const {
  return builtin_options_as_FloorModOptions();
}

template <>
inline const tflite::RangeOptions*
Operator::builtin_options_as<tflite::RangeOptions>() const {
  return builtin_options_as_RangeOptions();
}

template <>
inline const tflite::ResizeNearestNeighborOptions*
Operator::builtin_options_as<tflite::ResizeNearestNeighborOptions>() const {
  return builtin_options_as_ResizeNearestNeighborOptions();
}

template <>
inline const tflite::LeakyReluOptions*
Operator::builtin_options_as<tflite::LeakyReluOptions>() const {
  return builtin_options_as_LeakyReluOptions();
}

template <>
inline const tflite::SquaredDifferenceOptions*
Operator::builtin_options_as<tflite::SquaredDifferenceOptions>() const {
  return builtin_options_as_SquaredDifferenceOptions();
}

template <>
inline const tflite::MirrorPadOptions*
Operator::builtin_options_as<tflite::MirrorPadOptions>() const {
  return builtin_options_as_MirrorPadOptions();
}

template <>
inline const tflite::AbsOptions*
Operator::builtin_options_as<tflite::AbsOptions>() const {
  return builtin_options_as_AbsOptions();
}

template <>
inline const tflite::SplitVOptions*
Operator::builtin_options_as<tflite::SplitVOptions>() const {
  return builtin_options_as_SplitVOptions();
}

template <>
inline const tflite::UniqueOptions*
Operator::builtin_options_as<tflite::UniqueOptions>() const {
  return builtin_options_as_UniqueOptions();
}

template <>
inline const tflite::ReverseV2Options*
Operator::builtin_options_as<tflite::ReverseV2Options>() const {
  return builtin_options_as_ReverseV2Options();
}

template <>
inline const tflite::AddNOptions*
Operator::builtin_options_as<tflite::AddNOptions>() const {
  return builtin_options_as_AddNOptions();
}

template <>
inline const tflite::GatherNdOptions*
Operator::builtin_options_as<tflite::GatherNdOptions>() const {
  return builtin_options_as_GatherNdOptions();
}

template <>
inline const tflite::CosOptions*
Operator::builtin_options_as<tflite::CosOptions>() const {
  return builtin_options_as_CosOptions();
}

template <>
inline const tflite::WhereOptions*
Operator::builtin_options_as<tflite::WhereOptions>() const {
  return builtin_options_as_WhereOptions();
}

template <>
inline const tflite::RankOptions*
Operator::builtin_options_as<tflite::RankOptions>() const {
  return builtin_options_as_RankOptions();
}

template <>
inline const tflite::ReverseSequenceOptions*
Operator::builtin_options_as<tflite::ReverseSequenceOptions>() const {
  return builtin_options_as_ReverseSequenceOptions();
}

template <>
inline const tflite::MatrixDiagOptions*
Operator::builtin_options_as<tflite::MatrixDiagOptions>() const {
  return builtin_options_as_MatrixDiagOptions();
}

template <>
inline const tflite::QuantizeOptions*
Operator::builtin_options_as<tflite::QuantizeOptions>() const {
  return builtin_options_as_QuantizeOptions();
}

template <>
inline const tflite::MatrixSetDiagOptions*
Operator::builtin_options_as<tflite::MatrixSetDiagOptions>() const {
  return builtin_options_as_MatrixSetDiagOptions();
}

template <>
inline const tflite::HardSwishOptions*
Operator::builtin_options_as<tflite::HardSwishOptions>() const {
  return builtin_options_as_HardSwishOptions();
}

template <>
inline const tflite::IfOptions*
Operator::builtin_options_as<tflite::IfOptions>() const {
  return builtin_options_as_IfOptions();
}

template <>
inline const tflite::WhileOptions*
Operator::builtin_options_as<tflite::WhileOptions>() const {
  return builtin_options_as_WhileOptions();
}

template <>
inline const tflite::DepthToSpaceOptions*
Operator::builtin_options_as<tflite::DepthToSpaceOptions>() const {
  return builtin_options_as_DepthToSpaceOptions();
}

template <>
inline const tflite::NonMaxSuppressionV4Options*
Operator::builtin_options_as<tflite::NonMaxSuppressionV4Options>() const {
  return builtin_options_as_NonMaxSuppressionV4Options();
}

template <>
inline const tflite::NonMaxSuppressionV5Options*
Operator::builtin_options_as<tflite::NonMaxSuppressionV5Options>() const {
  return builtin_options_as_NonMaxSuppressionV5Options();
}

template <>
inline const tflite::ScatterNdOptions*
Operator::builtin_options_as<tflite::ScatterNdOptions>() const {
  return builtin_options_as_ScatterNdOptions();
}

template <>
inline const tflite::SelectV2Options*
Operator::builtin_options_as<tflite::SelectV2Options>() const {
  return builtin_options_as_SelectV2Options();
}

template <>
inline const tflite::DensifyOptions*
Operator::builtin_options_as<tflite::DensifyOptions>() const {
  return builtin_options_as_DensifyOptions();
}

template <>
inline const tflite::SegmentSumOptions*
Operator::builtin_options_as<tflite::SegmentSumOptions>() const {
  return builtin_options_as_SegmentSumOptions();
}

template <>
inline const tflite::BatchMatMulOptions*
Operator::builtin_options_as<tflite::BatchMatMulOptions>() const {
  return builtin_options_as_BatchMatMulOptions();
}

template <>
inline const tflite::CumsumOptions*
Operator::builtin_options_as<tflite::CumsumOptions>() const {
  return builtin_options_as_CumsumOptions();
}

template <>
inline const tflite::CallOnceOptions*
Operator::builtin_options_as<tflite::CallOnceOptions>() const {
  return builtin_options_as_CallOnceOptions();
}

template <>
inline const tflite::BroadcastToOptions*
Operator::builtin_options_as<tflite::BroadcastToOptions>() const {
  return builtin_options_as_BroadcastToOptions();
}

template <>
inline const tflite::Rfft2dOptions*
Operator::builtin_options_as<tflite::Rfft2dOptions>() const {
  return builtin_options_as_Rfft2dOptions();
}

template <>
inline const tflite::Conv3DOptions*
Operator::builtin_options_as<tflite::Conv3DOptions>() const {
  return builtin_options_as_Conv3DOptions();
}

template <>
inline const tflite::HashtableOptions*
Operator::builtin_options_as<tflite::HashtableOptions>() const {
  return builtin_options_as_HashtableOptions();
}

template <>
inline const tflite::HashtableFindOptions*
Operator::builtin_options_as<tflite::HashtableFindOptions>() const {
  return builtin_options_as_HashtableFindOptions();
}

template <>
inline const tflite::HashtableImportOptions*
Operator::builtin_options_as<tflite::HashtableImportOptions>() const {
  return builtin_options_as_HashtableImportOptions();
}

template <>
inline const tflite::HashtableSizeOptions*
Operator::builtin_options_as<tflite::HashtableSizeOptions>() const {
  return builtin_options_as_HashtableSizeOptions();
}

template <>
inline const tflite::VarHandleOptions*
Operator::builtin_options_as<tflite::VarHandleOptions>() const {
  return builtin_options_as_VarHandleOptions();
}

template <>
inline const tflite::ReadVariableOptions*
Operator::builtin_options_as<tflite::ReadVariableOptions>() const {
  return builtin_options_as_ReadVariableOptions();
}

template <>
inline const tflite::AssignVariableOptions*
Operator::builtin_options_as<tflite::AssignVariableOptions>() const {
  return builtin_options_as_AssignVariableOptions();
}

template <>
inline const tflite::RandomOptions*
Operator::builtin_options_as<tflite::RandomOptions>() const {
  return builtin_options_as_RandomOptions();
}

template <>
inline const tflite::BucketizeOptions*
Operator::builtin_options_as<tflite::BucketizeOptions>() const {
  return builtin_options_as_BucketizeOptions();
}

template <>
inline const tflite::GeluOptions*
Operator::builtin_options_as<tflite::GeluOptions>() const {
  return builtin_options_as_GeluOptions();
}

struct OperatorBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_opcode_index(uint32_t opcode_index) {
    fbb_.AddElement<uint32_t>(Operator::VT_OPCODE_INDEX, opcode_index, 0);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(Operator::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(Operator::VT_OUTPUTS, outputs);
  }
  void add_builtin_options_type(tflite::BuiltinOptions builtin_options_type) {
    fbb_.AddElement<uint8_t>(Operator::VT_BUILTIN_OPTIONS_TYPE,
                             static_cast<uint8_t>(builtin_options_type), 0);
  }
  void add_builtin_options(flatbuffers::Offset<void> builtin_options) {
    fbb_.AddOffset(Operator::VT_BUILTIN_OPTIONS, builtin_options);
  }
  void add_custom_options(
      flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options) {
    fbb_.AddOffset(Operator::VT_CUSTOM_OPTIONS, custom_options);
  }
  void add_custom_options_format(
      tflite::CustomOptionsFormat custom_options_format) {
    fbb_.AddElement<int8_t>(Operator::VT_CUSTOM_OPTIONS_FORMAT,
                            static_cast<int8_t>(custom_options_format), 0);
  }
  void add_mutating_variable_inputs(
      flatbuffers::Offset<flatbuffers::Vector<uint8_t>>
          mutating_variable_inputs) {
    fbb_.AddOffset(Operator::VT_MUTATING_VARIABLE_INPUTS,
                   mutating_variable_inputs);
  }
  void add_intermediates(
      flatbuffers::Offset<flatbuffers::Vector<int32_t>> intermediates) {
    fbb_.AddOffset(Operator::VT_INTERMEDIATES, intermediates);
  }
  explicit OperatorBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OperatorBuilder& operator=(const OperatorBuilder&);
  flatbuffers::Offset<Operator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline flatbuffers::Offset<Operator> CreateOperator(
    flatbuffers::FlatBufferBuilder& _fbb, uint32_t opcode_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    tflite::BuiltinOptions builtin_options_type = tflite::BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options = 0,
    tflite::CustomOptionsFormat custom_options_format =
        tflite::CustomOptionsFormat_FLEXBUFFERS,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs =
        0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> intermediates = 0) {
  OperatorBuilder builder_(_fbb);
  builder_.add_intermediates(intermediates);
  builder_.add_mutating_variable_inputs(mutating_variable_inputs);
  builder_.add_custom_options(custom_options);
  builder_.add_builtin_options(builtin_options);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_opcode_index(opcode_index);
  builder_.add_custom_options_format(custom_options_format);
  builder_.add_builtin_options_type(builtin_options_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Operator> CreateOperatorDirect(
    flatbuffers::FlatBufferBuilder& _fbb, uint32_t opcode_index = 0,
    const std::vector<int32_t>* inputs = nullptr,
    const std::vector<int32_t>* outputs = nullptr,
    tflite::BuiltinOptions builtin_options_type = tflite::BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0,
    const std::vector<uint8_t>* custom_options = nullptr,
    tflite::CustomOptionsFormat custom_options_format =
        tflite::CustomOptionsFormat_FLEXBUFFERS,
    const std::vector<uint8_t>* mutating_variable_inputs = nullptr,
    const std::vector<int32_t>* intermediates = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto custom_options__ =
      custom_options ? _fbb.CreateVector<uint8_t>(*custom_options) : 0;
  auto mutating_variable_inputs__ =
      mutating_variable_inputs
          ? _fbb.CreateVector<uint8_t>(*mutating_variable_inputs)
          : 0;
  auto intermediates__ =
      intermediates ? _fbb.CreateVector<int32_t>(*intermediates) : 0;
  return tflite::CreateOperator(_fbb, opcode_index, inputs__, outputs__,
                                builtin_options_type, builtin_options,
                                custom_options__, custom_options_format,
                                mutating_variable_inputs__, intermediates__);
}

struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SubGraphTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSORS = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_OPERATORS = 10,
    VT_NAME = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>>* tensors()
      const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>>*>(
        VT_TENSORS);
  }
  const flatbuffers::Vector<int32_t>* inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t>* outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>>* operators()
      const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>>*>(
        VT_OPERATORS);
  }
  const flatbuffers::String* name() const {
    return GetPointer<const flatbuffers::String*>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_OPERATORS) &&
           verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) &&
           VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct SubGraphBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensors(flatbuffers::Offset<
                   flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>>>
                       tensors) {
    fbb_.AddOffset(SubGraph::VT_TENSORS, tensors);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(SubGraph::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(SubGraph::VT_OUTPUTS, outputs);
  }
  void add_operators(flatbuffers::Offset<
                     flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>>>
                         operators) {
    fbb_.AddOffset(SubGraph::VT_OPERATORS, operators);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SubGraph::VT_NAME, name);
  }
  explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubGraphBuilder& operator=(const SubGraphBuilder&);
  flatbuffers::Offset<SubGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGraph> CreateSubGraph(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<tflite::Tensor>>>
        tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<tflite::Operator>>>
        operators = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  SubGraphBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_operators(operators);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_tensors(tensors);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<flatbuffers::Offset<tflite::Tensor>>* tensors = nullptr,
    const std::vector<int32_t>* inputs = nullptr,
    const std::vector<int32_t>* outputs = nullptr,
    const std::vector<flatbuffers::Offset<tflite::Operator>>* operators =
        nullptr,
    const char* name = nullptr) {
  auto tensors__ =
      tensors ? _fbb.CreateVector<flatbuffers::Offset<tflite::Tensor>>(*tensors)
              : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto operators__ =
      operators
          ? _fbb.CreateVector<flatbuffers::Offset<tflite::Operator>>(*operators)
          : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::CreateSubGraph(_fbb, tensors__, inputs__, outputs__,
                                operators__, name__);
}

struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return BufferTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t>* data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) && verifier.EndTable();
  }
};

struct BufferBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Buffer::VT_DATA, data);
  }
  explicit BufferBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferBuilder& operator=(const BufferBuilder&);
  flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Buffer> CreateBuffer(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Buffer> CreateBufferDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<uint8_t>* data = nullptr) {
  if (data) {
    _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 16);
  }
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return tflite::CreateBuffer(_fbb, data__);
}

struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return MetadataTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_BUFFER = 6
  };
  const flatbuffers::String* name() const {
    return GetPointer<const flatbuffers::String*>(VT_NAME);
  }
  uint32_t buffer() const { return GetField<uint32_t>(VT_BUFFER, 0); }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER) && verifier.EndTable();
  }
};

struct MetadataBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Metadata::VT_NAME, name);
  }
  void add_buffer(uint32_t buffer) {
    fbb_.AddElement<uint32_t>(Metadata::VT_BUFFER, buffer, 0);
  }
  explicit MetadataBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetadataBuilder& operator=(const MetadataBuilder&);
  flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metadata> CreateMetadata(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0, uint32_t buffer = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Metadata> CreateMetadataDirect(
    flatbuffers::FlatBufferBuilder& _fbb, const char* name = nullptr,
    uint32_t buffer = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::CreateMetadata(_fbb, name__, buffer);
}

struct TensorMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return TensorMapTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TENSOR_INDEX = 6
  };
  const flatbuffers::String* name() const {
    return GetPointer<const flatbuffers::String*>(VT_NAME);
  }
  uint32_t tensor_index() const {
    return GetField<uint32_t>(VT_TENSOR_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_TENSOR_INDEX) &&
           verifier.EndTable();
  }
};

struct TensorMapBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TensorMap::VT_NAME, name);
  }
  void add_tensor_index(uint32_t tensor_index) {
    fbb_.AddElement<uint32_t>(TensorMap::VT_TENSOR_INDEX, tensor_index, 0);
  }
  explicit TensorMapBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorMapBuilder& operator=(const TensorMapBuilder&);
  flatbuffers::Offset<TensorMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorMap> CreateTensorMap(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t tensor_index = 0) {
  TensorMapBuilder builder_(_fbb);
  builder_.add_tensor_index(tensor_index);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorMap> CreateTensorMapDirect(
    flatbuffers::FlatBufferBuilder& _fbb, const char* name = nullptr,
    uint32_t tensor_index = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::CreateTensorMap(_fbb, name__, tensor_index);
}

struct SignatureDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return SignatureDefTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUTS = 4,
    VT_OUTPUTS = 6,
    VT_SIGNATURE_KEY = 8,
    VT_SUBGRAPH_INDEX = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>* inputs()
      const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>*>(
        VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>* outputs()
      const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>*>(
        VT_OUTPUTS);
  }
  const flatbuffers::String* signature_key() const {
    return GetPointer<const flatbuffers::String*>(VT_SIGNATURE_KEY);
  }
  uint32_t subgraph_index() const {
    return GetField<uint32_t>(VT_SUBGRAPH_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyOffset(verifier, VT_SIGNATURE_KEY) &&
           verifier.VerifyString(signature_key()) &&
           VerifyField<uint32_t>(verifier, VT_SUBGRAPH_INDEX) &&
           verifier.EndTable();
  }
};

struct SignatureDefBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputs(flatbuffers::Offset<
                  flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>>
                      inputs) {
    fbb_.AddOffset(SignatureDef::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<
                   flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>>
                       outputs) {
    fbb_.AddOffset(SignatureDef::VT_OUTPUTS, outputs);
  }
  void add_signature_key(
      flatbuffers::Offset<flatbuffers::String> signature_key) {
    fbb_.AddOffset(SignatureDef::VT_SIGNATURE_KEY, signature_key);
  }
  void add_subgraph_index(uint32_t subgraph_index) {
    fbb_.AddElement<uint32_t>(SignatureDef::VT_SUBGRAPH_INDEX, subgraph_index,
                              0);
  }
  explicit SignatureDefBuilder(flatbuffers::FlatBufferBuilder& _fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignatureDefBuilder& operator=(const SignatureDefBuilder&);
  flatbuffers::Offset<SignatureDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignatureDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignatureDef> CreateSignatureDef(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>>
        inputs = 0,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<tflite::TensorMap>>>
        outputs = 0,
    flatbuffers::Offset<flatbuffers::String> signature_key = 0,
    uint32_t subgraph_index = 0) {
  SignatureDefBuilder builder_(_fbb);
  builder_.add_subgraph_index(subgraph_index);
  builder_.add_signature_key(signature_key);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignatureDef> CreateSignatureDefDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<flatbuffers::Offset<tflite::TensorMap>>* inputs = nullptr,
    const std::vector<flatbuffers::Offset<tflite::TensorMap>>* outputs =
        nullptr,
    const char* signature_key = nullptr, uint32_t subgraph_index = 0) {
  auto inputs__ =
      inputs
          ? _fbb.CreateVector<flatbuffers::Offset<tflite::TensorMap>>(*inputs)
          : 0;
  auto outputs__ =
      outputs
          ? _fbb.CreateVector<flatbuffers::Offset<tflite::TensorMap>>(*outputs)
          : 0;
  auto signature_key__ = signature_key ? _fbb.CreateString(signature_key) : 0;
  return tflite::CreateSignatureDef(_fbb, inputs__, outputs__, signature_key__,
                                    subgraph_index);
}

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable* MiniReflectTypeTable() {
    return ModelTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_OPERATOR_CODES = 6,
    VT_SUBGRAPHS = 8,
    VT_DESCRIPTION = 10,
    VT_BUFFERS = 12,
    VT_METADATA_BUFFER = 14,
    VT_METADATA = 16,
    VT_SIGNATURE_DEFS = 18
  };
  uint32_t version() const { return GetField<uint32_t>(VT_VERSION, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>>*
  operator_codes() const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>>*>(
        VT_OPERATOR_CODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>>* subgraphs()
      const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>>*>(
        VT_SUBGRAPHS);
  }
  const flatbuffers::String* description() const {
    return GetPointer<const flatbuffers::String*>(VT_DESCRIPTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>>* buffers()
      const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>>*>(
        VT_BUFFERS);
  }
  const flatbuffers::Vector<int32_t>* metadata_buffer() const {
    return GetPointer<const flatbuffers::Vector<int32_t>*>(VT_METADATA_BUFFER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>>* metadata()
      const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>>*>(
        VT_METADATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<tflite::SignatureDef>>*
  signature_defs() const {
    return GetPointer<
        const flatbuffers::Vector<flatbuffers::Offset<tflite::SignatureDef>>*>(
        VT_SIGNATURE_DEFS);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_OPERATOR_CODES) &&
           verifier.VerifyVector(operator_codes()) &&
           verifier.VerifyVectorOfTables(operator_codes()) &&
           VerifyOffset(verifier, VT_SUBGRAPHS) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           VerifyOffset(verifier, VT_METADATA_BUFFER) &&
           verifier.VerifyVector(metadata_buffer()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           verifier.VerifyVectorOfTables(metadata()) &&
           VerifyOffset(verifier, VT_SIGNATURE_DEFS) &&
           verifier.VerifyVector(signature_defs()) &&
           verifier.VerifyVectorOfTables(signature_defs()) &&
           verifier.EndTable();
  }
};

struct ModelBuilder {
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Model::VT_VERSION, version, 0);
  }
  void add_operator_codes(
      flatbuffers::Offset<
          flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>>>
          operator_codes) {
    fbb_.AddOffset(Model::VT_OPERATOR_CODES, operator_codes);
  }
  void add_subgraphs(flatbuffers::Offset<
                     flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>>>
                         subgraphs) {
    fbb_.AddOffset(Model::VT_SUBGRAPHS, subgraphs);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Model::VT_DESCRIPTION, description);
  }
  void add_buffers(flatbuffers::Offset<
                   flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>>>
                       buffers) {
    fbb_.AddOffset(Model::VT_BUFFERS, buffers);
  }
  void add_metadata_buffer(
      flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer) {
    fbb_.AddOffset(Model::VT_METADATA_BUFFER, metadata_buffer);
  }
  void add_metadata(flatbuffers::Offset<
                    flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>>>
                        metadata) {
    fbb_.AddOffset(Model::VT_METADATA, metadata);
  }
  void add_signature_defs(
      flatbuffers::Offset<
          flatbuffers::Vector<flatbuffers::Offset<tflite::SignatureDef>>>
          signature_defs) {
    fbb_.AddOffset(Model::VT_SIGNATURE_DEFS, signature_defs);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelBuilder& operator=(const ModelBuilder&);
  flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder& _fbb, uint32_t version = 0,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<tflite::OperatorCode>>>
        operator_codes = 0,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<tflite::SubGraph>>>
        subgraphs = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<tflite::Buffer>>>
        buffers = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer = 0,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<tflite::Metadata>>>
        metadata = 0,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<tflite::SignatureDef>>>
        signature_defs = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_signature_defs(signature_defs);
  builder_.add_metadata(metadata);
  builder_.add_metadata_buffer(metadata_buffer);
  builder_.add_buffers(buffers);
  builder_.add_description(description);
  builder_.add_subgraphs(subgraphs);
  builder_.add_operator_codes(operator_codes);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder& _fbb, uint32_t version = 0,
    const std::vector<flatbuffers::Offset<tflite::OperatorCode>>*
        operator_codes = nullptr,
    const std::vector<flatbuffers::Offset<tflite::SubGraph>>* subgraphs =
        nullptr,
    const char* description = nullptr,
    const std::vector<flatbuffers::Offset<tflite::Buffer>>* buffers = nullptr,
    const std::vector<int32_t>* metadata_buffer = nullptr,
    const std::vector<flatbuffers::Offset<tflite::Metadata>>* metadata =
        nullptr,
    const std::vector<flatbuffers::Offset<tflite::SignatureDef>>*
        signature_defs = nullptr) {
  auto operator_codes__ =
      operator_codes
          ? _fbb.CreateVector<flatbuffers::Offset<tflite::OperatorCode>>(
                *operator_codes)
          : 0;
  auto subgraphs__ =
      subgraphs
          ? _fbb.CreateVector<flatbuffers::Offset<tflite::SubGraph>>(*subgraphs)
          : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto buffers__ =
      buffers ? _fbb.CreateVector<flatbuffers::Offset<tflite::Buffer>>(*buffers)
              : 0;
  auto metadata_buffer__ =
      metadata_buffer ? _fbb.CreateVector<int32_t>(*metadata_buffer) : 0;
  auto metadata__ =
      metadata
          ? _fbb.CreateVector<flatbuffers::Offset<tflite::Metadata>>(*metadata)
          : 0;
  auto signature_defs__ =
      signature_defs
          ? _fbb.CreateVector<flatbuffers::Offset<tflite::SignatureDef>>(
                *signature_defs)
          : 0;
  return tflite::CreateModel(_fbb, version, operator_codes__, subgraphs__,
                             description__, buffers__, metadata_buffer__,
                             metadata__, signature_defs__);
}

inline bool VerifyQuantizationDetails(flatbuffers::Verifier& verifier,
                                      const void* obj,
                                      QuantizationDetails type) {
  switch (type) {
    case QuantizationDetails_NONE: {
      return true;
    }
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const tflite::CustomQuantization*>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool VerifyQuantizationDetailsVector(
    flatbuffers::Verifier& verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
    const flatbuffers::Vector<uint8_t>* types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyQuantizationDetails(verifier, values->Get(i),
                                   types->GetEnum<QuantizationDetails>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifySparseIndexVector(flatbuffers::Verifier& verifier,
                                    const void* obj, SparseIndexVector type) {
  switch (type) {
    case SparseIndexVector_NONE: {
      return true;
    }
    case SparseIndexVector_Int32Vector: {
      auto ptr = reinterpret_cast<const tflite::Int32Vector*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SparseIndexVector_Uint16Vector: {
      auto ptr = reinterpret_cast<const tflite::Uint16Vector*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SparseIndexVector_Uint8Vector: {
      auto ptr = reinterpret_cast<const tflite::Uint8Vector*>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool VerifySparseIndexVectorVector(
    flatbuffers::Verifier& verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
    const flatbuffers::Vector<uint8_t>* types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySparseIndexVector(verifier, values->Get(i),
                                 types->GetEnum<SparseIndexVector>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyBuiltinOptions(flatbuffers::Verifier& verifier,
                                 const void* obj, BuiltinOptions type) {
  switch (type) {
    case BuiltinOptions_NONE: {
      return true;
    }
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv2DOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthwiseConv2DOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatEmbeddingsOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const tflite::LSHProjectionOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const tflite::Pool2DOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const tflite::SVDFOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const tflite::RNNOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const tflite::FullyConnectedOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::SoftmaxOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const tflite::ConcatenationOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const tflite::AddOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const tflite::L2NormOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr =
          reinterpret_cast<const tflite::LocalResponseNormalizationOptions*>(
              obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const tflite::LSTMOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const tflite::ResizeBilinearOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ReshapeOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const tflite::SkipGramOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToDepthOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr =
          reinterpret_cast<const tflite::EmbeddingLookupSparseOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const tflite::MulOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const tflite::PadOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchToSpaceNDOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const tflite::SpaceToBatchNDOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const tflite::ReducerOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const tflite::SubOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const tflite::DivOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const tflite::SqueezeOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const tflite::SequenceRNNOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const tflite::StridedSliceOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const tflite::TopKV2Options*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const tflite::LogSoftmaxOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const tflite::CastOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::DequantizeOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const tflite::MaximumMinimumOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMaxOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const tflite::LessOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const tflite::NegOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const tflite::PadV2Options*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::GreaterEqualOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::LessEqualOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const tflite::SelectOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const tflite::SliceOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const tflite::TransposeConvOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const tflite::SparseToDenseOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const tflite::TileOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const tflite::ExpandDimsOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const tflite::EqualOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const tflite::NotEqualOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const tflite::ShapeOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const tflite::PowOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const tflite::ArgMinOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const tflite::FakeQuantOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const tflite::PackOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalOrOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const tflite::OneHotOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalAndOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const tflite::LogicalNotOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const tflite::UnpackOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorDivOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const tflite::SquareOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const tflite::ZerosLikeOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const tflite::FillOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr =
          reinterpret_cast<const tflite::BidirectionalSequenceLSTMOptions*>(
              obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr =
          reinterpret_cast<const tflite::BidirectionalSequenceRNNOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr =
          reinterpret_cast<const tflite::UnidirectionalSequenceLSTMOptions*>(
              obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const tflite::FloorModOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const tflite::RangeOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr =
          reinterpret_cast<const tflite::ResizeNearestNeighborOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const tflite::LeakyReluOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const tflite::SquaredDifferenceOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const tflite::MirrorPadOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const tflite::AbsOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const tflite::SplitVOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<const tflite::UniqueOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<const tflite::ReverseV2Options*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<const tflite::AddNOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<const tflite::GatherNdOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<const tflite::CosOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<const tflite::WhereOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<const tflite::RankOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<const tflite::ReverseSequenceOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MatrixDiagOptions: {
      auto ptr = reinterpret_cast<const tflite::MatrixDiagOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_QuantizeOptions: {
      auto ptr = reinterpret_cast<const tflite::QuantizeOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      auto ptr = reinterpret_cast<const tflite::MatrixSetDiagOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HardSwishOptions: {
      auto ptr = reinterpret_cast<const tflite::HardSwishOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_IfOptions: {
      auto ptr = reinterpret_cast<const tflite::IfOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhileOptions: {
      auto ptr = reinterpret_cast<const tflite::WhileOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      auto ptr = reinterpret_cast<const tflite::DepthToSpaceOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      auto ptr =
          reinterpret_cast<const tflite::NonMaxSuppressionV4Options*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      auto ptr =
          reinterpret_cast<const tflite::NonMaxSuppressionV5Options*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ScatterNdOptions: {
      auto ptr = reinterpret_cast<const tflite::ScatterNdOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectV2Options: {
      auto ptr = reinterpret_cast<const tflite::SelectV2Options*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DensifyOptions: {
      auto ptr = reinterpret_cast<const tflite::DensifyOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SegmentSumOptions: {
      auto ptr = reinterpret_cast<const tflite::SegmentSumOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchMatMulOptions: {
      auto ptr = reinterpret_cast<const tflite::BatchMatMulOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CumsumOptions: {
      auto ptr = reinterpret_cast<const tflite::CumsumOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOnceOptions: {
      auto ptr = reinterpret_cast<const tflite::CallOnceOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BroadcastToOptions: {
      auto ptr = reinterpret_cast<const tflite::BroadcastToOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Rfft2dOptions: {
      auto ptr = reinterpret_cast<const tflite::Rfft2dOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Conv3DOptions: {
      auto ptr = reinterpret_cast<const tflite::Conv3DOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableFindOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableFindOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableImportOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableImportOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableSizeOptions: {
      auto ptr = reinterpret_cast<const tflite::HashtableSizeOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_VarHandleOptions: {
      auto ptr = reinterpret_cast<const tflite::VarHandleOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReadVariableOptions: {
      auto ptr = reinterpret_cast<const tflite::ReadVariableOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AssignVariableOptions: {
      auto ptr = reinterpret_cast<const tflite::AssignVariableOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RandomOptions: {
      auto ptr = reinterpret_cast<const tflite::RandomOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BucketizeOptions: {
      auto ptr = reinterpret_cast<const tflite::BucketizeOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GeluOptions: {
      auto ptr = reinterpret_cast<const tflite::GeluOptions*>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool VerifyBuiltinOptionsVector(
    flatbuffers::Verifier& verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>>* values,
    const flatbuffers::Vector<uint8_t>* types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBuiltinOptions(verifier, values->Get(i),
                              types->GetEnum<BuiltinOptions>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable* TensorTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::TensorTypeTypeTable};
  static const char* const names[] = {
      "FLOAT32", "FLOAT16",  "INT32",     "UINT8", "INT64",   "STRING",
      "BOOL",    "INT16",    "COMPLEX64", "INT8",  "FLOAT64", "COMPLEX128",
      "UINT64",  "RESOURCE", "VARIANT",   "UINT32"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_ENUM, 16, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* QuantizationDetailsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_SEQUENCE, 0, -1}, {flatbuffers::ET_SEQUENCE, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::CustomQuantizationTypeTable};
  static const char* const names[] = {"NONE", "CustomQuantization"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* DimensionTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::DimensionTypeTypeTable};
  static const char* const names[] = {"DENSE", "SPARSE_CSR"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* SparseIndexVectorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_SEQUENCE, 0, -1},
      {flatbuffers::ET_SEQUENCE, 0, 0},
      {flatbuffers::ET_SEQUENCE, 0, 1},
      {flatbuffers::ET_SEQUENCE, 0, 2}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::Int32VectorTypeTable, tflite::Uint16VectorTypeTable,
      tflite::Uint8VectorTypeTable};
  static const char* const names[] = {"NONE", "Int32Vector", "Uint16Vector",
                                      "Uint8Vector"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* BuiltinOperatorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}, {flatbuffers::ET_INT, 0, 0},
      {flatbuffers::ET_INT, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::BuiltinOperatorTypeTable};
  static const char* const names[] = {"ADD",
                                      "AVERAGE_POOL_2D",
                                      "CONCATENATION",
                                      "CONV_2D",
                                      "DEPTHWISE_CONV_2D",
                                      "DEPTH_TO_SPACE",
                                      "DEQUANTIZE",
                                      "EMBEDDING_LOOKUP",
                                      "FLOOR",
                                      "FULLY_CONNECTED",
                                      "HASHTABLE_LOOKUP",
                                      "L2_NORMALIZATION",
                                      "L2_POOL_2D",
                                      "LOCAL_RESPONSE_NORMALIZATION",
                                      "LOGISTIC",
                                      "LSH_PROJECTION",
                                      "LSTM",
                                      "MAX_POOL_2D",
                                      "MUL",
                                      "RELU",
                                      "RELU_N1_TO_1",
                                      "RELU6",
                                      "RESHAPE",
                                      "RESIZE_BILINEAR",
                                      "RNN",
                                      "SOFTMAX",
                                      "SPACE_TO_DEPTH",
                                      "SVDF",
                                      "TANH",
                                      "CONCAT_EMBEDDINGS",
                                      "SKIP_GRAM",
                                      "CALL",
                                      "CUSTOM",
                                      "EMBEDDING_LOOKUP_SPARSE",
                                      "PAD",
                                      "UNIDIRECTIONAL_SEQUENCE_RNN",
                                      "GATHER",
                                      "BATCH_TO_SPACE_ND",
                                      "SPACE_TO_BATCH_ND",
                                      "TRANSPOSE",
                                      "MEAN",
                                      "SUB",
                                      "DIV",
                                      "SQUEEZE",
                                      "UNIDIRECTIONAL_SEQUENCE_LSTM",
                                      "STRIDED_SLICE",
                                      "BIDIRECTIONAL_SEQUENCE_RNN",
                                      "EXP",
                                      "TOPK_V2",
                                      "SPLIT",
                                      "LOG_SOFTMAX",
                                      "DELEGATE",
                                      "BIDIRECTIONAL_SEQUENCE_LSTM",
                                      "CAST",
                                      "PRELU",
                                      "MAXIMUM",
                                      "ARG_MAX",
                                      "MINIMUM",
                                      "LESS",
                                      "NEG",
                                      "PADV2",
                                      "GREATER",
                                      "GREATER_EQUAL",
                                      "LESS_EQUAL",
                                      "SELECT",
                                      "SLICE",
                                      "SIN",
                                      "TRANSPOSE_CONV",
                                      "SPARSE_TO_DENSE",
                                      "TILE",
                                      "EXPAND_DIMS",
                                      "EQUAL",
                                      "NOT_EQUAL",
                                      "LOG",
                                      "SUM",
                                      "SQRT",
                                      "RSQRT",
                                      "SHAPE",
                                      "POW",
                                      "ARG_MIN",
                                      "FAKE_QUANT",
                                      "REDUCE_PROD",
                                      "REDUCE_MAX",
                                      "PACK",
                                      "LOGICAL_OR",
                                      "ONE_HOT",
                                      "LOGICAL_AND",
                                      "LOGICAL_NOT",
                                      "UNPACK",
                                      "REDUCE_MIN",
                                      "FLOOR_DIV",
                                      "REDUCE_ANY",
                                      "SQUARE",
                                      "ZEROS_LIKE",
                                      "FILL",
                                      "FLOOR_MOD",
                                      "RANGE",
                                      "RESIZE_NEAREST_NEIGHBOR",
                                      "LEAKY_RELU",
                                      "SQUARED_DIFFERENCE",
                                      "MIRROR_PAD",
                                      "ABS",
                                      "SPLIT_V",
                                      "UNIQUE",
                                      "CEIL",
                                      "REVERSE_V2",
                                      "ADD_N",
                                      "GATHER_ND",
                                      "COS",
                                      "WHERE",
                                      "RANK",
                                      "ELU",
                                      "REVERSE_SEQUENCE",
                                      "MATRIX_DIAG",
                                      "QUANTIZE",
                                      "MATRIX_SET_DIAG",
                                      "ROUND",
                                      "HARD_SWISH",
                                      "IF",
                                      "WHILE",
                                      "NON_MAX_SUPPRESSION_V4",
                                      "NON_MAX_SUPPRESSION_V5",
                                      "SCATTER_ND",
                                      "SELECT_V2",
                                      "DENSIFY",
                                      "SEGMENT_SUM",
                                      "BATCH_MATMUL",
                                      "PLACEHOLDER_FOR_GREATER_OP_CODES",
                                      "CUMSUM",
                                      "CALL_ONCE",
                                      "BROADCAST_TO",
                                      "RFFT2D",
                                      "CONV_3D",
                                      "IMAG",
                                      "REAL",
                                      "COMPLEX_ABS",
                                      "HASHTABLE",
                                      "HASHTABLE_FIND",
                                      "HASHTABLE_IMPORT",
                                      "HASHTABLE_SIZE",
                                      "REDUCE_ALL",
                                      "CONV_3D_TRANSPOSE",
                                      "VAR_HANDLE",
                                      "READ_VARIABLE",
                                      "ASSIGN_VARIABLE",
                                      "BROADCAST_ARGS",
                                      "RANDOM_STANDARD_NORMAL",
                                      "BUCKETIZE",
                                      "RANDOM_UNIFORM",
                                      "MULTINOMIAL",
                                      "GELU"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_ENUM, 151, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* BuiltinOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_SEQUENCE, 0, -1},  {flatbuffers::ET_SEQUENCE, 0, 0},
      {flatbuffers::ET_SEQUENCE, 0, 1},   {flatbuffers::ET_SEQUENCE, 0, 2},
      {flatbuffers::ET_SEQUENCE, 0, 3},   {flatbuffers::ET_SEQUENCE, 0, 4},
      {flatbuffers::ET_SEQUENCE, 0, 5},   {flatbuffers::ET_SEQUENCE, 0, 6},
      {flatbuffers::ET_SEQUENCE, 0, 7},   {flatbuffers::ET_SEQUENCE, 0, 8},
      {flatbuffers::ET_SEQUENCE, 0, 9},   {flatbuffers::ET_SEQUENCE, 0, 10},
      {flatbuffers::ET_SEQUENCE, 0, 11},  {flatbuffers::ET_SEQUENCE, 0, 12},
      {flatbuffers::ET_SEQUENCE, 0, 13},  {flatbuffers::ET_SEQUENCE, 0, 14},
      {flatbuffers::ET_SEQUENCE, 0, 15},  {flatbuffers::ET_SEQUENCE, 0, 16},
      {flatbuffers::ET_SEQUENCE, 0, 17},  {flatbuffers::ET_SEQUENCE, 0, 18},
      {flatbuffers::ET_SEQUENCE, 0, 19},  {flatbuffers::ET_SEQUENCE, 0, 20},
      {flatbuffers::ET_SEQUENCE, 0, 21},  {flatbuffers::ET_SEQUENCE, 0, 22},
      {flatbuffers::ET_SEQUENCE, 0, 23},  {flatbuffers::ET_SEQUENCE, 0, 24},
      {flatbuffers::ET_SEQUENCE, 0, 25},  {flatbuffers::ET_SEQUENCE, 0, 26},
      {flatbuffers::ET_SEQUENCE, 0, 27},  {flatbuffers::ET_SEQUENCE, 0, 28},
      {flatbuffers::ET_SEQUENCE, 0, 29},  {flatbuffers::ET_SEQUENCE, 0, 30},
      {flatbuffers::ET_SEQUENCE, 0, 31},  {flatbuffers::ET_SEQUENCE, 0, 32},
      {flatbuffers::ET_SEQUENCE, 0, 33},  {flatbuffers::ET_SEQUENCE, 0, 34},
      {flatbuffers::ET_SEQUENCE, 0, 35},  {flatbuffers::ET_SEQUENCE, 0, 36},
      {flatbuffers::ET_SEQUENCE, 0, 37},  {flatbuffers::ET_SEQUENCE, 0, 38},
      {flatbuffers::ET_SEQUENCE, 0, 39},  {flatbuffers::ET_SEQUENCE, 0, 40},
      {flatbuffers::ET_SEQUENCE, 0, 41},  {flatbuffers::ET_SEQUENCE, 0, 42},
      {flatbuffers::ET_SEQUENCE, 0, 43},  {flatbuffers::ET_SEQUENCE, 0, 44},
      {flatbuffers::ET_SEQUENCE, 0, 45},  {flatbuffers::ET_SEQUENCE, 0, 46},
      {flatbuffers::ET_SEQUENCE, 0, 47},  {flatbuffers::ET_SEQUENCE, 0, 48},
      {flatbuffers::ET_SEQUENCE, 0, 49},  {flatbuffers::ET_SEQUENCE, 0, 50},
      {flatbuffers::ET_SEQUENCE, 0, 51},  {flatbuffers::ET_SEQUENCE, 0, 52},
      {flatbuffers::ET_SEQUENCE, 0, 53},  {flatbuffers::ET_SEQUENCE, 0, 54},
      {flatbuffers::ET_SEQUENCE, 0, 55},  {flatbuffers::ET_SEQUENCE, 0, 56},
      {flatbuffers::ET_SEQUENCE, 0, 57},  {flatbuffers::ET_SEQUENCE, 0, 58},
      {flatbuffers::ET_SEQUENCE, 0, 59},  {flatbuffers::ET_SEQUENCE, 0, 60},
      {flatbuffers::ET_SEQUENCE, 0, 61},  {flatbuffers::ET_SEQUENCE, 0, 62},
      {flatbuffers::ET_SEQUENCE, 0, 63},  {flatbuffers::ET_SEQUENCE, 0, 64},
      {flatbuffers::ET_SEQUENCE, 0, 65},  {flatbuffers::ET_SEQUENCE, 0, 66},
      {flatbuffers::ET_SEQUENCE, 0, 67},  {flatbuffers::ET_SEQUENCE, 0, 68},
      {flatbuffers::ET_SEQUENCE, 0, 69},  {flatbuffers::ET_SEQUENCE, 0, 70},
      {flatbuffers::ET_SEQUENCE, 0, 71},  {flatbuffers::ET_SEQUENCE, 0, 72},
      {flatbuffers::ET_SEQUENCE, 0, 73},  {flatbuffers::ET_SEQUENCE, 0, 74},
      {flatbuffers::ET_SEQUENCE, 0, 75},  {flatbuffers::ET_SEQUENCE, 0, 76},
      {flatbuffers::ET_SEQUENCE, 0, 77},  {flatbuffers::ET_SEQUENCE, 0, 78},
      {flatbuffers::ET_SEQUENCE, 0, 79},  {flatbuffers::ET_SEQUENCE, 0, 80},
      {flatbuffers::ET_SEQUENCE, 0, 81},  {flatbuffers::ET_SEQUENCE, 0, 82},
      {flatbuffers::ET_SEQUENCE, 0, 83},  {flatbuffers::ET_SEQUENCE, 0, 84},
      {flatbuffers::ET_SEQUENCE, 0, 85},  {flatbuffers::ET_SEQUENCE, 0, 86},
      {flatbuffers::ET_SEQUENCE, 0, 87},  {flatbuffers::ET_SEQUENCE, 0, 88},
      {flatbuffers::ET_SEQUENCE, 0, 89},  {flatbuffers::ET_SEQUENCE, 0, 90},
      {flatbuffers::ET_SEQUENCE, 0, 91},  {flatbuffers::ET_SEQUENCE, 0, 92},
      {flatbuffers::ET_SEQUENCE, 0, 93},  {flatbuffers::ET_SEQUENCE, 0, 94},
      {flatbuffers::ET_SEQUENCE, 0, 95},  {flatbuffers::ET_SEQUENCE, 0, 96},
      {flatbuffers::ET_SEQUENCE, 0, 97},  {flatbuffers::ET_SEQUENCE, 0, 98},
      {flatbuffers::ET_SEQUENCE, 0, 99},  {flatbuffers::ET_SEQUENCE, 0, 100},
      {flatbuffers::ET_SEQUENCE, 0, 101}, {flatbuffers::ET_SEQUENCE, 0, 102},
      {flatbuffers::ET_SEQUENCE, 0, 103}, {flatbuffers::ET_SEQUENCE, 0, 104},
      {flatbuffers::ET_SEQUENCE, 0, 105}, {flatbuffers::ET_SEQUENCE, 0, 106},
      {flatbuffers::ET_SEQUENCE, 0, 107}, {flatbuffers::ET_SEQUENCE, 0, 108},
      {flatbuffers::ET_SEQUENCE, 0, 109}, {flatbuffers::ET_SEQUENCE, 0, 110},
      {flatbuffers::ET_SEQUENCE, 0, 111}, {flatbuffers::ET_SEQUENCE, 0, 112},
      {flatbuffers::ET_SEQUENCE, 0, 113}, {flatbuffers::ET_SEQUENCE, 0, 114},
      {flatbuffers::ET_SEQUENCE, 0, 115}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::Conv2DOptionsTypeTable,
      tflite::DepthwiseConv2DOptionsTypeTable,
      tflite::ConcatEmbeddingsOptionsTypeTable,
      tflite::LSHProjectionOptionsTypeTable,
      tflite::Pool2DOptionsTypeTable,
      tflite::SVDFOptionsTypeTable,
      tflite::RNNOptionsTypeTable,
      tflite::FullyConnectedOptionsTypeTable,
      tflite::SoftmaxOptionsTypeTable,
      tflite::ConcatenationOptionsTypeTable,
      tflite::AddOptionsTypeTable,
      tflite::L2NormOptionsTypeTable,
      tflite::LocalResponseNormalizationOptionsTypeTable,
      tflite::LSTMOptionsTypeTable,
      tflite::ResizeBilinearOptionsTypeTable,
      tflite::CallOptionsTypeTable,
      tflite::ReshapeOptionsTypeTable,
      tflite::SkipGramOptionsTypeTable,
      tflite::SpaceToDepthOptionsTypeTable,
      tflite::EmbeddingLookupSparseOptionsTypeTable,
      tflite::MulOptionsTypeTable,
      tflite::PadOptionsTypeTable,
      tflite::GatherOptionsTypeTable,
      tflite::BatchToSpaceNDOptionsTypeTable,
      tflite::SpaceToBatchNDOptionsTypeTable,
      tflite::TransposeOptionsTypeTable,
      tflite::ReducerOptionsTypeTable,
      tflite::SubOptionsTypeTable,
      tflite::DivOptionsTypeTable,
      tflite::SqueezeOptionsTypeTable,
      tflite::SequenceRNNOptionsTypeTable,
      tflite::StridedSliceOptionsTypeTable,
      tflite::ExpOptionsTypeTable,
      tflite::TopKV2OptionsTypeTable,
      tflite::SplitOptionsTypeTable,
      tflite::LogSoftmaxOptionsTypeTable,
      tflite::CastOptionsTypeTable,
      tflite::DequantizeOptionsTypeTable,
      tflite::MaximumMinimumOptionsTypeTable,
      tflite::ArgMaxOptionsTypeTable,
      tflite::LessOptionsTypeTable,
      tflite::NegOptionsTypeTable,
      tflite::PadV2OptionsTypeTable,
      tflite::GreaterOptionsTypeTable,
      tflite::GreaterEqualOptionsTypeTable,
      tflite::LessEqualOptionsTypeTable,
      tflite::SelectOptionsTypeTable,
      tflite::SliceOptionsTypeTable,
      tflite::TransposeConvOptionsTypeTable,
      tflite::SparseToDenseOptionsTypeTable,
      tflite::TileOptionsTypeTable,
      tflite::ExpandDimsOptionsTypeTable,
      tflite::EqualOptionsTypeTable,
      tflite::NotEqualOptionsTypeTable,
      tflite::ShapeOptionsTypeTable,
      tflite::PowOptionsTypeTable,
      tflite::ArgMinOptionsTypeTable,
      tflite::FakeQuantOptionsTypeTable,
      tflite::PackOptionsTypeTable,
      tflite::LogicalOrOptionsTypeTable,
      tflite::OneHotOptionsTypeTable,
      tflite::LogicalAndOptionsTypeTable,
      tflite::LogicalNotOptionsTypeTable,
      tflite::UnpackOptionsTypeTable,
      tflite::FloorDivOptionsTypeTable,
      tflite::SquareOptionsTypeTable,
      tflite::ZerosLikeOptionsTypeTable,
      tflite::FillOptionsTypeTable,
      tflite::BidirectionalSequenceLSTMOptionsTypeTable,
      tflite::BidirectionalSequenceRNNOptionsTypeTable,
      tflite::UnidirectionalSequenceLSTMOptionsTypeTable,
      tflite::FloorModOptionsTypeTable,
      tflite::RangeOptionsTypeTable,
      tflite::ResizeNearestNeighborOptionsTypeTable,
      tflite::LeakyReluOptionsTypeTable,
      tflite::SquaredDifferenceOptionsTypeTable,
      tflite::MirrorPadOptionsTypeTable,
      tflite::AbsOptionsTypeTable,
      tflite::SplitVOptionsTypeTable,
      tflite::UniqueOptionsTypeTable,
      tflite::ReverseV2OptionsTypeTable,
      tflite::AddNOptionsTypeTable,
      tflite::GatherNdOptionsTypeTable,
      tflite::CosOptionsTypeTable,
      tflite::WhereOptionsTypeTable,
      tflite::RankOptionsTypeTable,
      tflite::ReverseSequenceOptionsTypeTable,
      tflite::MatrixDiagOptionsTypeTable,
      tflite::QuantizeOptionsTypeTable,
      tflite::MatrixSetDiagOptionsTypeTable,
      tflite::HardSwishOptionsTypeTable,
      tflite::IfOptionsTypeTable,
      tflite::WhileOptionsTypeTable,
      tflite::DepthToSpaceOptionsTypeTable,
      tflite::NonMaxSuppressionV4OptionsTypeTable,
      tflite::NonMaxSuppressionV5OptionsTypeTable,
      tflite::ScatterNdOptionsTypeTable,
      tflite::SelectV2OptionsTypeTable,
      tflite::DensifyOptionsTypeTable,
      tflite::SegmentSumOptionsTypeTable,
      tflite::BatchMatMulOptionsTypeTable,
      tflite::CumsumOptionsTypeTable,
      tflite::CallOnceOptionsTypeTable,
      tflite::BroadcastToOptionsTypeTable,
      tflite::Rfft2dOptionsTypeTable,
      tflite::Conv3DOptionsTypeTable,
      tflite::HashtableOptionsTypeTable,
      tflite::HashtableFindOptionsTypeTable,
      tflite::HashtableImportOptionsTypeTable,
      tflite::HashtableSizeOptionsTypeTable,
      tflite::VarHandleOptionsTypeTable,
      tflite::ReadVariableOptionsTypeTable,
      tflite::AssignVariableOptionsTypeTable,
      tflite::RandomOptionsTypeTable,
      tflite::BucketizeOptionsTypeTable,
      tflite::GeluOptionsTypeTable};
  static const char* const names[] = {"NONE",
                                      "Conv2DOptions",
                                      "DepthwiseConv2DOptions",
                                      "ConcatEmbeddingsOptions",
                                      "LSHProjectionOptions",
                                      "Pool2DOptions",
                                      "SVDFOptions",
                                      "RNNOptions",
                                      "FullyConnectedOptions",
                                      "SoftmaxOptions",
                                      "ConcatenationOptions",
                                      "AddOptions",
                                      "L2NormOptions",
                                      "LocalResponseNormalizationOptions",
                                      "LSTMOptions",
                                      "ResizeBilinearOptions",
                                      "CallOptions",
                                      "ReshapeOptions",
                                      "SkipGramOptions",
                                      "SpaceToDepthOptions",
                                      "EmbeddingLookupSparseOptions",
                                      "MulOptions",
                                      "PadOptions",
                                      "GatherOptions",
                                      "BatchToSpaceNDOptions",
                                      "SpaceToBatchNDOptions",
                                      "TransposeOptions",
                                      "ReducerOptions",
                                      "SubOptions",
                                      "DivOptions",
                                      "SqueezeOptions",
                                      "SequenceRNNOptions",
                                      "StridedSliceOptions",
                                      "ExpOptions",
                                      "TopKV2Options",
                                      "SplitOptions",
                                      "LogSoftmaxOptions",
                                      "CastOptions",
                                      "DequantizeOptions",
                                      "MaximumMinimumOptions",
                                      "ArgMaxOptions",
                                      "LessOptions",
                                      "NegOptions",
                                      "PadV2Options",
                                      "GreaterOptions",
                                      "GreaterEqualOptions",
                                      "LessEqualOptions",
                                      "SelectOptions",
                                      "SliceOptions",
                                      "TransposeConvOptions",
                                      "SparseToDenseOptions",
                                      "TileOptions",
                                      "ExpandDimsOptions",
                                      "EqualOptions",
                                      "NotEqualOptions",
                                      "ShapeOptions",
                                      "PowOptions",
                                      "ArgMinOptions",
                                      "FakeQuantOptions",
                                      "PackOptions",
                                      "LogicalOrOptions",
                                      "OneHotOptions",
                                      "LogicalAndOptions",
                                      "LogicalNotOptions",
                                      "UnpackOptions",
                                      "FloorDivOptions",
                                      "SquareOptions",
                                      "ZerosLikeOptions",
                                      "FillOptions",
                                      "BidirectionalSequenceLSTMOptions",
                                      "BidirectionalSequenceRNNOptions",
                                      "UnidirectionalSequenceLSTMOptions",
                                      "FloorModOptions",
                                      "RangeOptions",
                                      "ResizeNearestNeighborOptions",
                                      "LeakyReluOptions",
                                      "SquaredDifferenceOptions",
                                      "MirrorPadOptions",
                                      "AbsOptions",
                                      "SplitVOptions",
                                      "UniqueOptions",
                                      "ReverseV2Options",
                                      "AddNOptions",
                                      "GatherNdOptions",
                                      "CosOptions",
                                      "WhereOptions",
                                      "RankOptions",
                                      "ReverseSequenceOptions",
                                      "MatrixDiagOptions",
                                      "QuantizeOptions",
                                      "MatrixSetDiagOptions",
                                      "HardSwishOptions",
                                      "IfOptions",
                                      "WhileOptions",
                                      "DepthToSpaceOptions",
                                      "NonMaxSuppressionV4Options",
                                      "NonMaxSuppressionV5Options",
                                      "ScatterNdOptions",
                                      "SelectV2Options",
                                      "DensifyOptions",
                                      "SegmentSumOptions",
                                      "BatchMatMulOptions",
                                      "CumsumOptions",
                                      "CallOnceOptions",
                                      "BroadcastToOptions",
                                      "Rfft2dOptions",
                                      "Conv3DOptions",
                                      "HashtableOptions",
                                      "HashtableFindOptions",
                                      "HashtableImportOptions",
                                      "HashtableSizeOptions",
                                      "VarHandleOptions",
                                      "ReadVariableOptions",
                                      "AssignVariableOptions",
                                      "RandomOptions",
                                      "BucketizeOptions",
                                      "GeluOptions"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_UNION, 117, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* PaddingTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::PaddingTypeTable};
  static const char* const names[] = {"SAME", "VALID"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* ActivationFunctionTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"NONE",  "RELU", "RELU_N1_TO_1",
                                      "RELU6", "TANH", "SIGN_BIT"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_ENUM, 6, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* LSHProjectionTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::LSHProjectionTypeTypeTable};
  static const char* const names[] = {"UNKNOWN", "SPARSE", "DENSE"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable*
FullyConnectedOptionsWeightsFormatTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::FullyConnectedOptionsWeightsFormatTypeTable};
  static const char* const names[] = {"DEFAULT", "SHUFFLED4x16INT8"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* LSTMKernelTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::LSTMKernelTypeTypeTable};
  static const char* const names[] = {"FULL", "BASIC"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* CombinerTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::CombinerTypeTypeTable};
  static const char* const names[] = {"SUM", "MEAN", "SQRTN"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* MirrorPadModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::MirrorPadModeTypeTable};
  static const char* const names[] = {"REFLECT", "SYMMETRIC"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* CustomOptionsFormatTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::CustomOptionsFormatTypeTable};
  static const char* const names[] = {"FLEXBUFFERS"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_ENUM, 1, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* CustomQuantizationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_UCHAR, 1, -1}};
  static const char* const names[] = {"custom"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* QuantizationParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_FLOAT, 1, -1}, {flatbuffers::ET_FLOAT, 1, -1},
      {flatbuffers::ET_FLOAT, 1, -1}, {flatbuffers::ET_LONG, 1, -1},
      {flatbuffers::ET_UTYPE, 0, 0},  {flatbuffers::ET_SEQUENCE, 0, 0},
      {flatbuffers::ET_INT, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::QuantizationDetailsTypeTable};
  static const char* const names[] = {"min",
                                      "max",
                                      "scale",
                                      "zero_point",
                                      "details_type",
                                      "details",
                                      "quantized_dimension"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* Int32VectorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 1, -1}};
  static const char* const names[] = {"values"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* Uint16VectorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_USHORT, 1, -1}};
  static const char* const names[] = {"values"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* Uint8VectorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_UCHAR, 1, -1}};
  static const char* const names[] = {"values"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* DimensionMetadataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0},  {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_UTYPE, 0, 1}, {flatbuffers::ET_SEQUENCE, 0, 1},
      {flatbuffers::ET_UTYPE, 0, 1}, {flatbuffers::ET_SEQUENCE, 0, 1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::DimensionTypeTypeTable, tflite::SparseIndexVectorTypeTable};
  static const char* const names[] = {
      "format",         "dense_size",         "array_segments_type",
      "array_segments", "array_indices_type", "array_indices"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* SparsityParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 1, -1},
      {flatbuffers::ET_INT, 1, -1},
      {flatbuffers::ET_SEQUENCE, 1, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::DimensionMetadataTypeTable};
  static const char* const names[] = {"traversal_order", "block_map",
                                      "dim_metadata"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* TensorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 1, -1},     {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_UINT, 0, -1},    {flatbuffers::ET_STRING, 0, -1},
      {flatbuffers::ET_SEQUENCE, 0, 1}, {flatbuffers::ET_BOOL, 0, -1},
      {flatbuffers::ET_SEQUENCE, 0, 2}, {flatbuffers::ET_INT, 1, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::TensorTypeTypeTable, tflite::QuantizationParametersTypeTable,
      tflite::SparsityParametersTypeTable};
  static const char* const names[] = {
      "shape",        "type",        "buffer",   "name",
      "quantization", "is_variable", "sparsity", "shape_signature"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* Conv2DOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_CHAR, 0, 1},
      {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::PaddingTypeTable, tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {
      "padding",           "stride_w",
      "stride_h",          "fused_activation_function",
      "dilation_w_factor", "dilation_h_factor"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* Conv3DOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_CHAR, 0, 1}, {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::PaddingTypeTable, tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"padding",
                                      "stride_d",
                                      "stride_w",
                                      "stride_h",
                                      "fused_activation_function",
                                      "dilation_d_factor",
                                      "dilation_w_factor",
                                      "dilation_h_factor"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* Pool2DOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_CHAR, 0, 1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::PaddingTypeTable, tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {
      "padding",      "stride_w",      "stride_h",
      "filter_width", "filter_height", "fused_activation_function"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* DepthwiseConv2DOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_CHAR, 0, 1}, {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::PaddingTypeTable, tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"padding",
                                      "stride_w",
                                      "stride_h",
                                      "depth_multiplier",
                                      "fused_activation_function",
                                      "dilation_w_factor",
                                      "dilation_h_factor"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* ConcatEmbeddingsOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 1, -1},
      {flatbuffers::ET_INT, 1, -1}};
  static const char* const names[] = {"num_channels", "num_columns_per_channel",
                                      "embedding_dim_per_channel"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* LSHProjectionOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::LSHProjectionTypeTypeTable};
  static const char* const names[] = {"type"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* SVDFOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_BOOL, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"rank", "fused_activation_function",
                                      "asymmetric_quantize_inputs"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* RNNOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_BOOL, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"fused_activation_function",
                                      "asymmetric_quantize_inputs"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* SequenceRNNOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_BOOL, 0, -1},
      {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_BOOL, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"time_major", "fused_activation_function",
                                      "asymmetric_quantize_inputs"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable*
BidirectionalSequenceRNNOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_BOOL, 0, -1},
      {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_BOOL, 0, -1},
      {flatbuffers::ET_BOOL, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"time_major", "fused_activation_function",
                                      "merge_outputs",
                                      "asymmetric_quantize_inputs"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* FullyConnectedOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 1},
      {flatbuffers::ET_BOOL, 0, -1},
      {flatbuffers::ET_BOOL, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable,
      tflite::FullyConnectedOptionsWeightsFormatTypeTable};
  static const char* const names[] = {"fused_activation_function",
                                      "weights_format", "keep_num_dims",
                                      "asymmetric_quantize_inputs"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* SoftmaxOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_FLOAT, 0, -1}};
  static const char* const names[] = {"beta"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* ConcatenationOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"axis", "fused_activation_function"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* AddOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_BOOL, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"fused_activation_function",
                                      "pot_scale_int16"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* MulOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"fused_activation_function"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* L2NormOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"fused_activation_function"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable*
LocalResponseNormalizationOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_FLOAT, 0, -1},
      {flatbuffers::ET_FLOAT, 0, -1},
      {flatbuffers::ET_FLOAT, 0, -1}};
  static const char* const names[] = {"radius", "bias", "alpha", "beta"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* LSTMOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_FLOAT, 0, -1},
      {flatbuffers::ET_FLOAT, 0, -1},
      {flatbuffers::ET_CHAR, 0, 1},
      {flatbuffers::ET_BOOL, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable, tflite::LSTMKernelTypeTypeTable};
  static const char* const names[] = {"fused_activation_function", "cell_clip",
                                      "proj_clip", "kernel_type",
                                      "asymmetric_quantize_inputs"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable*
UnidirectionalSequenceLSTMOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_FLOAT, 0, -1},
      {flatbuffers::ET_FLOAT, 0, -1},
      {flatbuffers::ET_BOOL, 0, -1},
      {flatbuffers::ET_BOOL, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"fused_activation_function", "cell_clip",
                                      "proj_clip", "time_major",
                                      "asymmetric_quantize_inputs"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable*
BidirectionalSequenceLSTMOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0},   {flatbuffers::ET_FLOAT, 0, -1},
      {flatbuffers::ET_FLOAT, 0, -1}, {flatbuffers::ET_BOOL, 0, -1},
      {flatbuffers::ET_BOOL, 0, -1},  {flatbuffers::ET_BOOL, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"fused_activation_function",
                                      "cell_clip",
                                      "proj_clip",
                                      "merge_outputs",
                                      "time_major",
                                      "asymmetric_quantize_inputs"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* ResizeBilinearOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_BOOL, 0, -1},
      {flatbuffers::ET_BOOL, 0, -1}};
  static const char* const names[] = {"new_height", "new_width",
                                      "align_corners", "half_pixel_centers"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* ResizeNearestNeighborOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_BOOL, 0, -1}, {flatbuffers::ET_BOOL, 0, -1}};
  static const char* const names[] = {"align_corners", "half_pixel_centers"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* CallOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_UINT, 0, -1}};
  static const char* const names[] = {"subgraph"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* PadOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* PadV2OptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* ReshapeOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 1, -1}};
  static const char* const names[] = {"new_shape"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* SpaceToBatchNDOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* BatchToSpaceNDOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* SkipGramOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_BOOL, 0, -1}};
  static const char* const names[] = {"ngram_size", "max_skip_size",
                                      "include_all_ngrams"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* SpaceToDepthOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1}};
  static const char* const names[] = {"block_size"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* DepthToSpaceOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1}};
  static const char* const names[] = {"block_size"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* SubOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_BOOL, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"fused_activation_function",
                                      "pot_scale_int16"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* DivOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::ActivationFunctionTypeTypeTable};
  static const char* const names[] = {"fused_activation_function"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* TopKV2OptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* EmbeddingLookupSparseOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::CombinerTypeTypeTable};
  static const char* const names[] = {"combiner"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* GatherOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
  static const char* const names[] = {"axis", "batch_dims"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* TransposeOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* ExpOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* CosOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* ReducerOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_BOOL, 0, -1}};
  static const char* const names[] = {"keep_dims"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* SqueezeOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 1, -1}};
  static const char* const names[] = {"squeeze_dims"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* SplitOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1}};
  static const char* const names[] = {"num_splits"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* SplitVOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1}};
  static const char* const names[] = {"num_splits"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* StridedSliceOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, -1}};
  static const char* const names[] = {"begin_mask", "end_mask", "ellipsis_mask",
                                      "new_axis_mask", "shrink_axis_mask"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* LogSoftmaxOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* CastOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}, {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::TensorTypeTypeTable};
  static const char* const names[] = {"in_data_type", "out_data_type"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* DequantizeOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* MaximumMinimumOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* TileOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* ArgMaxOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::TensorTypeTypeTable};
  static const char* const names[] = {"output_type"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* ArgMinOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::TensorTypeTypeTable};
  static const char* const names[] = {"output_type"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* GreaterOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* GreaterEqualOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* LessOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* LessEqualOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* NegOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* SelectOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* SliceOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* TransposeConvOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::PaddingTypeTable};
  static const char* const names[] = {"padding", "stride_w", "stride_h"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* ExpandDimsOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* SparseToDenseOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_BOOL, 0, -1}};
  static const char* const names[] = {"validate_indices"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* EqualOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* NotEqualOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* ShapeOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::TensorTypeTypeTable};
  static const char* const names[] = {"out_type"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* RankOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* PowOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* FakeQuantOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_FLOAT, 0, -1},
      {flatbuffers::ET_FLOAT, 0, -1},
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_BOOL, 0, -1}};
  static const char* const names[] = {"min", "max", "num_bits", "narrow_range"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* PackOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
  static const char* const names[] = {"values_count", "axis"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* LogicalOrOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* OneHotOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1}};
  static const char* const names[] = {"axis"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* AbsOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* HardSwishOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* LogicalAndOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* LogicalNotOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* UnpackOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
  static const char* const names[] = {"num", "axis"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* FloorDivOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* SquareOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* ZerosLikeOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* FillOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* FloorModOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* RangeOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* LeakyReluOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_FLOAT, 0, -1}};
  static const char* const names[] = {"alpha"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* SquaredDifferenceOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* MirrorPadOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::MirrorPadModeTypeTable};
  static const char* const names[] = {"mode"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* UniqueOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::TensorTypeTypeTable};
  static const char* const names[] = {"idx_out_type"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* ReverseV2OptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* AddNOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* GatherNdOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* WhereOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* ReverseSequenceOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
  static const char* const names[] = {"seq_dim", "batch_dim"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* MatrixDiagOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* QuantizeOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* MatrixSetDiagOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* IfOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
  static const char* const names[] = {"then_subgraph_index",
                                      "else_subgraph_index"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* CallOnceOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1}};
  static const char* const names[] = {"init_subgraph_index"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* WhileOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1}, {flatbuffers::ET_INT, 0, -1}};
  static const char* const names[] = {"cond_subgraph_index",
                                      "body_subgraph_index"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* NonMaxSuppressionV4OptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* NonMaxSuppressionV5OptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* ScatterNdOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* SelectV2OptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* DensifyOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* SegmentSumOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* BatchMatMulOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_BOOL, 0, -1},
      {flatbuffers::ET_BOOL, 0, -1},
      {flatbuffers::ET_BOOL, 0, -1}};
  static const char* const names[] = {"adj_x", "adj_y",
                                      "asymmetric_quantize_inputs"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* CumsumOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_BOOL, 0, -1}, {flatbuffers::ET_BOOL, 0, -1}};
  static const char* const names[] = {"exclusive", "reverse"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* BroadcastToOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* Rfft2dOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* HashtableOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_CHAR, 0, 0},
      {flatbuffers::ET_CHAR, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::TensorTypeTypeTable};
  static const char* const names[] = {"table_id", "key_dtype", "value_dtype"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* HashtableFindOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* HashtableImportOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* HashtableSizeOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* VarHandleOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_STRING, 0, -1}, {flatbuffers::ET_STRING, 0, -1}};
  static const char* const names[] = {"container", "shared_name"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* ReadVariableOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* AssignVariableOptionsTypeTable() {
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr};
  return &tt;
}

inline const flatbuffers::TypeTable* RandomOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_LONG, 0, -1}, {flatbuffers::ET_LONG, 0, -1}};
  static const char* const names[] = {"seed", "seed2"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* BucketizeOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_FLOAT, 1, -1}};
  static const char* const names[] = {"boundaries"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* GeluOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_BOOL, 0, -1}};
  static const char* const names[] = {"approximate"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* OperatorCodeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_CHAR, 0, -1},
      {flatbuffers::ET_STRING, 0, -1},
      {flatbuffers::ET_INT, 0, -1},
      {flatbuffers::ET_INT, 0, 0}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::BuiltinOperatorTypeTable};
  static const char* const names[] = {"deprecated_builtin_code", "custom_code",
                                      "version", "builtin_code"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* OperatorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_UINT, 0, -1},    {flatbuffers::ET_INT, 1, -1},
      {flatbuffers::ET_INT, 1, -1},     {flatbuffers::ET_UTYPE, 0, 0},
      {flatbuffers::ET_SEQUENCE, 0, 0}, {flatbuffers::ET_UCHAR, 1, -1},
      {flatbuffers::ET_CHAR, 0, 1},     {flatbuffers::ET_BOOL, 1, -1},
      {flatbuffers::ET_INT, 1, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::BuiltinOptionsTypeTable, tflite::CustomOptionsFormatTypeTable};
  static const char* const names[] = {"opcode_index",
                                      "inputs",
                                      "outputs",
                                      "builtin_options_type",
                                      "builtin_options",
                                      "custom_options",
                                      "custom_options_format",
                                      "mutating_variable_inputs",
                                      "intermediates"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* SubGraphTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_SEQUENCE, 1, 0},
      {flatbuffers::ET_INT, 1, -1},
      {flatbuffers::ET_INT, 1, -1},
      {flatbuffers::ET_SEQUENCE, 1, 1},
      {flatbuffers::ET_STRING, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::TensorTypeTable, tflite::OperatorTypeTable};
  static const char* const names[] = {"tensors", "inputs", "outputs",
                                      "operators", "name"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* BufferTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_UCHAR, 1, -1}};
  static const char* const names[] = {"data"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* MetadataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_STRING, 0, -1}, {flatbuffers::ET_UINT, 0, -1}};
  static const char* const names[] = {"name", "buffer"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* TensorMapTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_STRING, 0, -1}, {flatbuffers::ET_UINT, 0, -1}};
  static const char* const names[] = {"name", "tensor_index"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* SignatureDefTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_SEQUENCE, 1, 0},
      {flatbuffers::ET_SEQUENCE, 1, 0},
      {flatbuffers::ET_STRING, 0, -1},
      {flatbuffers::ET_STRING, 0, -1},
      {flatbuffers::ET_UINT, 0, -1}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::TensorMapTypeTable};
  static const char* const names[] = {"inputs", "outputs", "signature_key",
                                      "deprecated_tag", "subgraph_index"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const flatbuffers::TypeTable* ModelTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
      {flatbuffers::ET_UINT, 0, -1},    {flatbuffers::ET_SEQUENCE, 1, 0},
      {flatbuffers::ET_SEQUENCE, 1, 1}, {flatbuffers::ET_STRING, 0, -1},
      {flatbuffers::ET_SEQUENCE, 1, 2}, {flatbuffers::ET_INT, 1, -1},
      {flatbuffers::ET_SEQUENCE, 1, 3}, {flatbuffers::ET_SEQUENCE, 1, 4}};
  static const flatbuffers::TypeFunction type_refs[] = {
      tflite::OperatorCodeTypeTable, tflite::SubGraphTypeTable,
      tflite::BufferTypeTable, tflite::MetadataTypeTable,
      tflite::SignatureDefTypeTable};
  static const char* const names[] = {
      "version", "operator_codes",  "subgraphs", "description",
      "buffers", "metadata_buffer", "metadata",  "signature_defs"};
  static const flatbuffers::TypeTable tt = {
      flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, names};
  return &tt;
}

inline const tflite::Model* GetModel(const void* buf) {
  return flatbuffers::GetRoot<tflite::Model>(buf);
}

inline const tflite::Model* GetSizePrefixedModel(const void* buf) {
  return flatbuffers::GetSizePrefixedRoot<tflite::Model>(buf);
}

inline const char* ModelIdentifier() { return "TFL3"; }

inline bool ModelBufferHasIdentifier(const void* buf) {
  return flatbuffers::BufferHasIdentifier(buf, ModelIdentifier());
}

inline bool VerifyModelBuffer(flatbuffers::Verifier& verifier) {
  return verifier.VerifyBuffer<tflite::Model>(ModelIdentifier());
}

inline bool VerifySizePrefixedModelBuffer(flatbuffers::Verifier& verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::Model>(ModelIdentifier());
}

inline const char* ModelExtension() { return "tflite"; }

inline void FinishModelBuffer(flatbuffers::FlatBufferBuilder& fbb,
                              flatbuffers::Offset<tflite::Model> root) {
  fbb.Finish(root, ModelIdentifier());
}

inline void FinishSizePrefixedModelBuffer(
    flatbuffers::FlatBufferBuilder& fbb,
    flatbuffers::Offset<tflite::Model> root) {
  fbb.FinishSizePrefixed(root, ModelIdentifier());
}

}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_
